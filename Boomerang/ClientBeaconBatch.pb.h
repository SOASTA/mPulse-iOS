// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ClientBeaconBatch.proto

#ifndef PROTOBUF_ClientBeaconBatch_2eproto__INCLUDED
#define PROTOBUF_ClientBeaconBatch_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace client_beacon_batch {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

class ClientBeaconBatch;
class ClientBeaconBatch_ClientBeaconBatchRecord;
class ClientBeaconBatch_ClientBeaconBatchRecord_TimerData;
class ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers;
class ClientBeaconBatch_ClientBeaconRecord;
class ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData;
class ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData;
class ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData;
class ClientBeaconBatch_ClientBeaconRecord_AppLaunchData;
class ClientBeaconBatch_ClientBeaconRecord_AppInactiveData;
class ClientBeaconBatch_ClientBeaconRecord_AppCrashData;
class ClientBeaconBatch_SessionInfo;

enum ClientBeaconBatch_BeaconType {
  ClientBeaconBatch_BeaconType_PAGE_VIEW = 0,
  ClientBeaconBatch_BeaconType_MANUAL = 1,
  ClientBeaconBatch_BeaconType_SPA = 2,
  ClientBeaconBatch_BeaconType_SPA_HARD = 3,
  ClientBeaconBatch_BeaconType_XHR = 4,
  ClientBeaconBatch_BeaconType_CLICK = 5,
  ClientBeaconBatch_BeaconType_API = 6,
  ClientBeaconBatch_BeaconType_API_NETWORK_REQUEST = 7,
  ClientBeaconBatch_BeaconType_API_CUSTOM_METRIC = 8,
  ClientBeaconBatch_BeaconType_API_CUSTOM_TIMER = 9,
  ClientBeaconBatch_BeaconType_APP_LAUNCH = 10,
  ClientBeaconBatch_BeaconType_APP_INACTIVE = 11,
  ClientBeaconBatch_BeaconType_APP_CRASH = 12,
  ClientBeaconBatch_BeaconType_BATCH = 13
};
bool ClientBeaconBatch_BeaconType_IsValid(int value);
const ClientBeaconBatch_BeaconType ClientBeaconBatch_BeaconType_BeaconType_MIN = ClientBeaconBatch_BeaconType_PAGE_VIEW;
const ClientBeaconBatch_BeaconType ClientBeaconBatch_BeaconType_BeaconType_MAX = ClientBeaconBatch_BeaconType_BATCH;
const int ClientBeaconBatch_BeaconType_BeaconType_ARRAYSIZE = ClientBeaconBatch_BeaconType_BeaconType_MAX + 1;

// ===================================================================

class ClientBeaconBatch_ClientBeaconBatchRecord_TimerData : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_ClientBeaconBatchRecord_TimerData();
  virtual ~ClientBeaconBatch_ClientBeaconBatchRecord_TimerData();

  ClientBeaconBatch_ClientBeaconBatchRecord_TimerData(const ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& from);

  inline ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& operator=(const ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& from);
  void MergeFrom(const ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline ::google::protobuf::int32 total() const;
  inline void set_total(::google::protobuf::int32 value);

  // optional int32 min = 2;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 2;
  inline ::google::protobuf::int32 min() const;
  inline void set_min(::google::protobuf::int32 value);

  // optional int32 max = 3;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 3;
  inline ::google::protobuf::int32 max() const;
  inline void set_max(::google::protobuf::int32 value);

  // optional int64 sum = 4;
  inline bool has_sum() const;
  inline void clear_sum();
  static const int kSumFieldNumber = 4;
  inline ::google::protobuf::int64 sum() const;
  inline void set_sum(::google::protobuf::int64 value);

  // optional int64 sum_sq = 5;
  inline bool has_sum_sq() const;
  inline void clear_sum_sq();
  static const int kSumSqFieldNumber = 5;
  inline ::google::protobuf::int64 sum_sq() const;
  inline void set_sum_sq(::google::protobuf::int64 value);

  // optional bytes histogram = 6;
  inline bool has_histogram() const;
  inline void clear_histogram();
  static const int kHistogramFieldNumber = 6;
  inline const ::std::string& histogram() const;
  inline void set_histogram(const ::std::string& value);
  inline void set_histogram(const char* value);
  inline void set_histogram(const void* value, size_t size);
  inline ::std::string* mutable_histogram();
  inline ::std::string* release_histogram();
  inline void set_allocated_histogram(::std::string* histogram);

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_min();
  inline void clear_has_min();
  inline void set_has_max();
  inline void clear_has_max();
  inline void set_has_sum();
  inline void clear_has_sum();
  inline void set_has_sum_sq();
  inline void clear_has_sum_sq();
  inline void set_has_histogram();
  inline void clear_has_histogram();

  ::google::protobuf::int32 total_;
  ::google::protobuf::int32 min_;
  ::google::protobuf::int64 sum_;
  ::google::protobuf::int64 sum_sq_;
  ::std::string* histogram_;
  ::google::protobuf::int32 max_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers();
  virtual ~ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers();

  ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers(const ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& from);

  inline ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& operator=(const ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& from);
  void MergeFrom(const ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData request_duration_timer = 1;
  inline bool has_request_duration_timer() const;
  inline void clear_request_duration_timer();
  static const int kRequestDurationTimerFieldNumber = 1;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& request_duration_timer() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* mutable_request_duration_timer();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* release_request_duration_timer();
  inline void set_allocated_request_duration_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* request_duration_timer);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData dns_timer = 2;
  inline bool has_dns_timer() const;
  inline void clear_dns_timer();
  static const int kDnsTimerFieldNumber = 2;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& dns_timer() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* mutable_dns_timer();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* release_dns_timer();
  inline void set_allocated_dns_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* dns_timer);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData tcp_timer = 3;
  inline bool has_tcp_timer() const;
  inline void clear_tcp_timer();
  static const int kTcpTimerFieldNumber = 3;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& tcp_timer() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* mutable_tcp_timer();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* release_tcp_timer();
  inline void set_allocated_tcp_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* tcp_timer);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData ssl_timer = 4;
  inline bool has_ssl_timer() const;
  inline void clear_ssl_timer();
  static const int kSslTimerFieldNumber = 4;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ssl_timer() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* mutable_ssl_timer();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* release_ssl_timer();
  inline void set_allocated_ssl_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ssl_timer);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData time_to_first_byte_timer = 5;
  inline bool has_time_to_first_byte_timer() const;
  inline void clear_time_to_first_byte_timer();
  static const int kTimeToFirstByteTimerFieldNumber = 5;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& time_to_first_byte_timer() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* mutable_time_to_first_byte_timer();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* release_time_to_first_byte_timer();
  inline void set_allocated_time_to_first_byte_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* time_to_first_byte_timer);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData time_to_last_byte_timer = 6;
  inline bool has_time_to_last_byte_timer() const;
  inline void clear_time_to_last_byte_timer();
  static const int kTimeToLastByteTimerFieldNumber = 6;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& time_to_last_byte_timer() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* mutable_time_to_last_byte_timer();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* release_time_to_last_byte_timer();
  inline void set_allocated_time_to_last_byte_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* time_to_last_byte_timer);

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.NetworkTimers)
 private:
  inline void set_has_request_duration_timer();
  inline void clear_has_request_duration_timer();
  inline void set_has_dns_timer();
  inline void clear_has_dns_timer();
  inline void set_has_tcp_timer();
  inline void clear_has_tcp_timer();
  inline void set_has_ssl_timer();
  inline void clear_has_ssl_timer();
  inline void set_has_time_to_first_byte_timer();
  inline void clear_has_time_to_first_byte_timer();
  inline void set_has_time_to_last_byte_timer();
  inline void clear_has_time_to_last_byte_timer();

  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* request_duration_timer_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* dns_timer_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* tcp_timer_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ssl_timer_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* time_to_first_byte_timer_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* time_to_last_byte_timer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch_ClientBeaconBatchRecord : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_ClientBeaconBatchRecord();
  virtual ~ClientBeaconBatch_ClientBeaconBatchRecord();

  ClientBeaconBatch_ClientBeaconBatchRecord(const ClientBeaconBatch_ClientBeaconBatchRecord& from);

  inline ClientBeaconBatch_ClientBeaconBatchRecord& operator=(const ClientBeaconBatch_ClientBeaconBatchRecord& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_ClientBeaconBatchRecord& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_ClientBeaconBatchRecord* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_ClientBeaconBatchRecord* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_ClientBeaconBatchRecord* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_ClientBeaconBatchRecord& from);
  void MergeFrom(const ClientBeaconBatch_ClientBeaconBatchRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClientBeaconBatch_ClientBeaconBatchRecord_TimerData TimerData;
  typedef ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers NetworkTimers;

  // accessors -------------------------------------------------------

  // optional string page_group = 1;
  inline bool has_page_group() const;
  inline void clear_page_group();
  static const int kPageGroupFieldNumber = 1;
  inline const ::std::string& page_group() const;
  inline void set_page_group(const ::std::string& value);
  inline void set_page_group(const char* value);
  inline void set_page_group(const char* value, size_t size);
  inline ::std::string* mutable_page_group();
  inline ::std::string* release_page_group();
  inline void set_allocated_page_group(::std::string* page_group);

  // optional string ab_test = 2;
  inline bool has_ab_test() const;
  inline void clear_ab_test();
  static const int kAbTestFieldNumber = 2;
  inline const ::std::string& ab_test() const;
  inline void set_ab_test(const ::std::string& value);
  inline void set_ab_test(const char* value);
  inline void set_ab_test(const char* value, size_t size);
  inline ::std::string* mutable_ab_test();
  inline ::std::string* release_ab_test();
  inline void set_allocated_ab_test(::std::string* ab_test);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional int32 network_error_code = 4;
  inline bool has_network_error_code() const;
  inline void clear_network_error_code();
  static const int kNetworkErrorCodeFieldNumber = 4;
  inline ::google::protobuf::int32 network_error_code() const;
  inline void set_network_error_code(::google::protobuf::int32 value);

  // optional int64 timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.NetworkTimers network_timers = 6;
  inline bool has_network_timers() const;
  inline void clear_network_timers();
  static const int kNetworkTimersFieldNumber = 6;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& network_timers() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* mutable_network_timers();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* release_network_timers();
  inline void set_allocated_network_timers(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* network_timers);

  // repeated .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData custom_timers = 7;
  inline int custom_timers_size() const;
  inline void clear_custom_timers();
  static const int kCustomTimersFieldNumber = 7;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& custom_timers(int index) const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* mutable_custom_timers(int index);
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* add_custom_timers();
  inline const ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData >&
      custom_timers() const;
  inline ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData >*
      mutable_custom_timers();

  // repeated int64 custom_metrics = 8;
  inline int custom_metrics_size() const;
  inline void clear_custom_metrics();
  static const int kCustomMetricsFieldNumber = 8;
  inline ::google::protobuf::int64 custom_metrics(int index) const;
  inline void set_custom_metrics(int index, ::google::protobuf::int64 value);
  inline void add_custom_metrics(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      custom_metrics() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_custom_metrics();

  // optional int32 beacon_total = 9;
  inline bool has_beacon_total() const;
  inline void clear_beacon_total();
  static const int kBeaconTotalFieldNumber = 9;
  inline ::google::protobuf::int32 beacon_total() const;
  inline void set_beacon_total(::google::protobuf::int32 value);

  // optional int32 crashes_total = 10;
  inline bool has_crashes_total() const;
  inline void clear_crashes_total();
  static const int kCrashesTotalFieldNumber = 10;
  inline ::google::protobuf::int32 crashes_total() const;
  inline void set_crashes_total(::google::protobuf::int32 value);

  // optional int32 installs_total = 11;
  inline bool has_installs_total() const;
  inline void clear_installs_total();
  static const int kInstallsTotalFieldNumber = 11;
  inline ::google::protobuf::int32 installs_total() const;
  inline void set_installs_total(::google::protobuf::int32 value);

  // repeated string custom_dimensions = 12;
  inline int custom_dimensions_size() const;
  inline void clear_custom_dimensions();
  static const int kCustomDimensionsFieldNumber = 12;
  inline const ::std::string& custom_dimensions(int index) const;
  inline ::std::string* mutable_custom_dimensions(int index);
  inline void set_custom_dimensions(int index, const ::std::string& value);
  inline void set_custom_dimensions(int index, const char* value);
  inline void set_custom_dimensions(int index, const char* value, size_t size);
  inline ::std::string* add_custom_dimensions();
  inline void add_custom_dimensions(const ::std::string& value);
  inline void add_custom_dimensions(const char* value);
  inline void add_custom_dimensions(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& custom_dimensions() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_custom_dimensions();

  // optional string beacon_type = 13;
  inline bool has_beacon_type() const;
  inline void clear_beacon_type();
  static const int kBeaconTypeFieldNumber = 13;
  inline const ::std::string& beacon_type() const;
  inline void set_beacon_type(const ::std::string& value);
  inline void set_beacon_type(const char* value);
  inline void set_beacon_type(const char* value, size_t size);
  inline ::std::string* mutable_beacon_type();
  inline ::std::string* release_beacon_type();
  inline void set_allocated_beacon_type(::std::string* beacon_type);

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord)
 private:
  inline void set_has_page_group();
  inline void clear_has_page_group();
  inline void set_has_ab_test();
  inline void clear_has_ab_test();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_network_error_code();
  inline void clear_has_network_error_code();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_network_timers();
  inline void clear_has_network_timers();
  inline void set_has_beacon_total();
  inline void clear_has_beacon_total();
  inline void set_has_crashes_total();
  inline void clear_has_crashes_total();
  inline void set_has_installs_total();
  inline void clear_has_installs_total();
  inline void set_has_beacon_type();
  inline void clear_has_beacon_type();

  ::std::string* page_group_;
  ::std::string* ab_test_;
  ::std::string* url_;
  ::google::protobuf::int64 timestamp_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* network_timers_;
  ::google::protobuf::int32 network_error_code_;
  ::google::protobuf::int32 beacon_total_;
  ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData > custom_timers_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > custom_metrics_;
  ::google::protobuf::int32 crashes_total_;
  ::google::protobuf::int32 installs_total_;
  ::google::protobuf::RepeatedPtrField< ::std::string> custom_dimensions_;
  ::std::string* beacon_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_ClientBeaconBatchRecord* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData();
  virtual ~ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData();

  ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData(const ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData& from);

  inline ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData& operator=(const ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData& from);
  void MergeFrom(const ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 duration = 1;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 1;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // optional string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional int32 network_error_code = 3;
  inline bool has_network_error_code() const;
  inline void clear_network_error_code();
  static const int kNetworkErrorCodeFieldNumber = 3;
  inline ::google::protobuf::int32 network_error_code() const;
  inline void set_network_error_code(::google::protobuf::int32 value);

  // optional int32 dns = 4;
  inline bool has_dns() const;
  inline void clear_dns();
  static const int kDnsFieldNumber = 4;
  inline ::google::protobuf::int32 dns() const;
  inline void set_dns(::google::protobuf::int32 value);

  // optional int32 tcp = 5;
  inline bool has_tcp() const;
  inline void clear_tcp();
  static const int kTcpFieldNumber = 5;
  inline ::google::protobuf::int32 tcp() const;
  inline void set_tcp(::google::protobuf::int32 value);

  // optional int32 ssl = 6;
  inline bool has_ssl() const;
  inline void clear_ssl();
  static const int kSslFieldNumber = 6;
  inline ::google::protobuf::int32 ssl() const;
  inline void set_ssl(::google::protobuf::int32 value);

  // optional int32 ttfb = 7;
  inline bool has_ttfb() const;
  inline void clear_ttfb();
  static const int kTtfbFieldNumber = 7;
  inline ::google::protobuf::int32 ttfb() const;
  inline void set_ttfb(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.ApiNetworkRequestData)
 private:
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_network_error_code();
  inline void clear_has_network_error_code();
  inline void set_has_dns();
  inline void clear_has_dns();
  inline void set_has_tcp();
  inline void clear_has_tcp();
  inline void set_has_ssl();
  inline void clear_has_ssl();
  inline void set_has_ttfb();
  inline void clear_has_ttfb();

  ::std::string* url_;
  ::google::protobuf::int32 duration_;
  ::google::protobuf::int32 network_error_code_;
  ::google::protobuf::int32 dns_;
  ::google::protobuf::int32 tcp_;
  ::google::protobuf::int32 ssl_;
  ::google::protobuf::int32 ttfb_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData();
  virtual ~ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData();

  ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData(const ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData& from);

  inline ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData& operator=(const ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData& from);
  void MergeFrom(const ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 timer_value = 1;
  inline bool has_timer_value() const;
  inline void clear_timer_value();
  static const int kTimerValueFieldNumber = 1;
  inline ::google::protobuf::int32 timer_value() const;
  inline void set_timer_value(::google::protobuf::int32 value);

  // optional int32 timer_index = 2;
  inline bool has_timer_index() const;
  inline void clear_timer_index();
  static const int kTimerIndexFieldNumber = 2;
  inline ::google::protobuf::int32 timer_index() const;
  inline void set_timer_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.ApiCustomTimerData)
 private:
  inline void set_has_timer_value();
  inline void clear_has_timer_value();
  inline void set_has_timer_index();
  inline void clear_has_timer_index();

  ::google::protobuf::int32 timer_value_;
  ::google::protobuf::int32 timer_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData();
  virtual ~ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData();

  ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData(const ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData& from);

  inline ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData& operator=(const ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData& from);
  void MergeFrom(const ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 metric_value = 1;
  inline bool has_metric_value() const;
  inline void clear_metric_value();
  static const int kMetricValueFieldNumber = 1;
  inline ::google::protobuf::int32 metric_value() const;
  inline void set_metric_value(::google::protobuf::int32 value);

  // optional int32 metric_index = 2;
  inline bool has_metric_index() const;
  inline void clear_metric_index();
  static const int kMetricIndexFieldNumber = 2;
  inline ::google::protobuf::int32 metric_index() const;
  inline void set_metric_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.ApiCustomMetricData)
 private:
  inline void set_has_metric_value();
  inline void clear_has_metric_value();
  inline void set_has_metric_index();
  inline void clear_has_metric_index();

  ::google::protobuf::int32 metric_value_;
  ::google::protobuf::int32 metric_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch_ClientBeaconRecord_AppLaunchData : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_ClientBeaconRecord_AppLaunchData();
  virtual ~ClientBeaconBatch_ClientBeaconRecord_AppLaunchData();

  ClientBeaconBatch_ClientBeaconRecord_AppLaunchData(const ClientBeaconBatch_ClientBeaconRecord_AppLaunchData& from);

  inline ClientBeaconBatch_ClientBeaconRecord_AppLaunchData& operator=(const ClientBeaconBatch_ClientBeaconRecord_AppLaunchData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_ClientBeaconRecord_AppLaunchData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_ClientBeaconRecord_AppLaunchData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_ClientBeaconRecord_AppLaunchData* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_ClientBeaconRecord_AppLaunchData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_ClientBeaconRecord_AppLaunchData& from);
  void MergeFrom(const ClientBeaconBatch_ClientBeaconRecord_AppLaunchData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_first_install = 1;
  inline bool has_is_first_install() const;
  inline void clear_is_first_install();
  static const int kIsFirstInstallFieldNumber = 1;
  inline bool is_first_install() const;
  inline void set_is_first_install(bool value);

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.AppLaunchData)
 private:
  inline void set_has_is_first_install();
  inline void clear_has_is_first_install();

  bool is_first_install_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_ClientBeaconRecord_AppLaunchData* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch_ClientBeaconRecord_AppInactiveData : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_ClientBeaconRecord_AppInactiveData();
  virtual ~ClientBeaconBatch_ClientBeaconRecord_AppInactiveData();

  ClientBeaconBatch_ClientBeaconRecord_AppInactiveData(const ClientBeaconBatch_ClientBeaconRecord_AppInactiveData& from);

  inline ClientBeaconBatch_ClientBeaconRecord_AppInactiveData& operator=(const ClientBeaconBatch_ClientBeaconRecord_AppInactiveData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_ClientBeaconRecord_AppInactiveData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_ClientBeaconRecord_AppInactiveData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_ClientBeaconRecord_AppInactiveData* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_ClientBeaconRecord_AppInactiveData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_ClientBeaconRecord_AppInactiveData& from);
  void MergeFrom(const ClientBeaconBatch_ClientBeaconRecord_AppInactiveData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.AppInactiveData)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_ClientBeaconRecord_AppInactiveData* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch_ClientBeaconRecord_AppCrashData : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_ClientBeaconRecord_AppCrashData();
  virtual ~ClientBeaconBatch_ClientBeaconRecord_AppCrashData();

  ClientBeaconBatch_ClientBeaconRecord_AppCrashData(const ClientBeaconBatch_ClientBeaconRecord_AppCrashData& from);

  inline ClientBeaconBatch_ClientBeaconRecord_AppCrashData& operator=(const ClientBeaconBatch_ClientBeaconRecord_AppCrashData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_ClientBeaconRecord_AppCrashData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_ClientBeaconRecord_AppCrashData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_ClientBeaconRecord_AppCrashData* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_ClientBeaconRecord_AppCrashData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_ClientBeaconRecord_AppCrashData& from);
  void MergeFrom(const ClientBeaconBatch_ClientBeaconRecord_AppCrashData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional string function = 3;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 3;
  inline const ::std::string& function() const;
  inline void set_function(const ::std::string& value);
  inline void set_function(const char* value);
  inline void set_function(const char* value, size_t size);
  inline ::std::string* mutable_function();
  inline ::std::string* release_function();
  inline void set_allocated_function(::std::string* function);

  // optional string file = 4;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 4;
  inline const ::std::string& file() const;
  inline void set_file(const ::std::string& value);
  inline void set_file(const char* value);
  inline void set_file(const char* value, size_t size);
  inline ::std::string* mutable_file();
  inline ::std::string* release_file();
  inline void set_allocated_file(::std::string* file);

  // optional int32 line = 5;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 5;
  inline ::google::protobuf::int32 line() const;
  inline void set_line(::google::protobuf::int32 value);

  // optional int32 character = 6;
  inline bool has_character() const;
  inline void clear_character();
  static const int kCharacterFieldNumber = 6;
  inline ::google::protobuf::int32 character() const;
  inline void set_character(::google::protobuf::int32 value);

  // optional string stack = 7;
  inline bool has_stack() const;
  inline void clear_stack();
  static const int kStackFieldNumber = 7;
  inline const ::std::string& stack() const;
  inline void set_stack(const ::std::string& value);
  inline void set_stack(const char* value);
  inline void set_stack(const char* value, size_t size);
  inline ::std::string* mutable_stack();
  inline ::std::string* release_stack();
  inline void set_allocated_stack(::std::string* stack);

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.AppCrashData)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_function();
  inline void clear_has_function();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_line();
  inline void clear_has_line();
  inline void set_has_character();
  inline void clear_has_character();
  inline void set_has_stack();
  inline void clear_has_stack();

  ::std::string* message_;
  ::std::string* function_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 line_;
  ::std::string* file_;
  ::std::string* stack_;
  ::google::protobuf::int32 character_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_ClientBeaconRecord_AppCrashData* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch_ClientBeaconRecord : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_ClientBeaconRecord();
  virtual ~ClientBeaconBatch_ClientBeaconRecord();

  ClientBeaconBatch_ClientBeaconRecord(const ClientBeaconBatch_ClientBeaconRecord& from);

  inline ClientBeaconBatch_ClientBeaconRecord& operator=(const ClientBeaconBatch_ClientBeaconRecord& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_ClientBeaconRecord& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_ClientBeaconRecord* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_ClientBeaconRecord* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_ClientBeaconRecord* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_ClientBeaconRecord& from);
  void MergeFrom(const ClientBeaconBatch_ClientBeaconRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData ApiNetworkRequestData;
  typedef ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData ApiCustomTimerData;
  typedef ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData ApiCustomMetricData;
  typedef ClientBeaconBatch_ClientBeaconRecord_AppLaunchData AppLaunchData;
  typedef ClientBeaconBatch_ClientBeaconRecord_AppInactiveData AppInactiveData;
  typedef ClientBeaconBatch_ClientBeaconRecord_AppCrashData AppCrashData;

  // accessors -------------------------------------------------------

  // optional int64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional .client_beacon_batch.ClientBeaconBatch.BeaconType beacon_type = 2;
  inline bool has_beacon_type() const;
  inline void clear_beacon_type();
  static const int kBeaconTypeFieldNumber = 2;
  inline ::client_beacon_batch::ClientBeaconBatch_BeaconType beacon_type() const;
  inline void set_beacon_type(::client_beacon_batch::ClientBeaconBatch_BeaconType value);

  // optional string page_group = 3;
  inline bool has_page_group() const;
  inline void clear_page_group();
  static const int kPageGroupFieldNumber = 3;
  inline const ::std::string& page_group() const;
  inline void set_page_group(const ::std::string& value);
  inline void set_page_group(const char* value);
  inline void set_page_group(const char* value, size_t size);
  inline ::std::string* mutable_page_group();
  inline ::std::string* release_page_group();
  inline void set_allocated_page_group(::std::string* page_group);

  // optional string ab_test = 4;
  inline bool has_ab_test() const;
  inline void clear_ab_test();
  static const int kAbTestFieldNumber = 4;
  inline const ::std::string& ab_test() const;
  inline void set_ab_test(const ::std::string& value);
  inline void set_ab_test(const char* value);
  inline void set_ab_test(const char* value, size_t size);
  inline ::std::string* mutable_ab_test();
  inline ::std::string* release_ab_test();
  inline void set_allocated_ab_test(::std::string* ab_test);

  // repeated string custom_dimensions = 5;
  inline int custom_dimensions_size() const;
  inline void clear_custom_dimensions();
  static const int kCustomDimensionsFieldNumber = 5;
  inline const ::std::string& custom_dimensions(int index) const;
  inline ::std::string* mutable_custom_dimensions(int index);
  inline void set_custom_dimensions(int index, const ::std::string& value);
  inline void set_custom_dimensions(int index, const char* value);
  inline void set_custom_dimensions(int index, const char* value, size_t size);
  inline ::std::string* add_custom_dimensions();
  inline void add_custom_dimensions(const ::std::string& value);
  inline void add_custom_dimensions(const char* value);
  inline void add_custom_dimensions(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& custom_dimensions() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_custom_dimensions();

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.ApiNetworkRequestData api_network_request_data = 6;
  inline bool has_api_network_request_data() const;
  inline void clear_api_network_request_data();
  static const int kApiNetworkRequestDataFieldNumber = 6;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData& api_network_request_data() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData* mutable_api_network_request_data();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData* release_api_network_request_data();
  inline void set_allocated_api_network_request_data(::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData* api_network_request_data);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.ApiCustomTimerData api_custom_timer_data = 7;
  inline bool has_api_custom_timer_data() const;
  inline void clear_api_custom_timer_data();
  static const int kApiCustomTimerDataFieldNumber = 7;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData& api_custom_timer_data() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData* mutable_api_custom_timer_data();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData* release_api_custom_timer_data();
  inline void set_allocated_api_custom_timer_data(::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData* api_custom_timer_data);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.ApiCustomMetricData api_custom_metric_data = 8;
  inline bool has_api_custom_metric_data() const;
  inline void clear_api_custom_metric_data();
  static const int kApiCustomMetricDataFieldNumber = 8;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData& api_custom_metric_data() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData* mutable_api_custom_metric_data();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData* release_api_custom_metric_data();
  inline void set_allocated_api_custom_metric_data(::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData* api_custom_metric_data);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.AppLaunchData app_launch_data = 9;
  inline bool has_app_launch_data() const;
  inline void clear_app_launch_data();
  static const int kAppLaunchDataFieldNumber = 9;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppLaunchData& app_launch_data() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppLaunchData* mutable_app_launch_data();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppLaunchData* release_app_launch_data();
  inline void set_allocated_app_launch_data(::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppLaunchData* app_launch_data);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.AppInactiveData app_inactive_data = 10;
  inline bool has_app_inactive_data() const;
  inline void clear_app_inactive_data();
  static const int kAppInactiveDataFieldNumber = 10;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppInactiveData& app_inactive_data() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppInactiveData* mutable_app_inactive_data();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppInactiveData* release_app_inactive_data();
  inline void set_allocated_app_inactive_data(::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppInactiveData* app_inactive_data);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.AppCrashData app_crash_data = 11;
  inline bool has_app_crash_data() const;
  inline void clear_app_crash_data();
  static const int kAppCrashDataFieldNumber = 11;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppCrashData& app_crash_data() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppCrashData* mutable_app_crash_data();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppCrashData* release_app_crash_data();
  inline void set_allocated_app_crash_data(::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppCrashData* app_crash_data);

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_beacon_type();
  inline void clear_has_beacon_type();
  inline void set_has_page_group();
  inline void clear_has_page_group();
  inline void set_has_ab_test();
  inline void clear_has_ab_test();
  inline void set_has_api_network_request_data();
  inline void clear_has_api_network_request_data();
  inline void set_has_api_custom_timer_data();
  inline void clear_has_api_custom_timer_data();
  inline void set_has_api_custom_metric_data();
  inline void clear_has_api_custom_metric_data();
  inline void set_has_app_launch_data();
  inline void clear_has_app_launch_data();
  inline void set_has_app_inactive_data();
  inline void clear_has_app_inactive_data();
  inline void set_has_app_crash_data();
  inline void clear_has_app_crash_data();

  ::google::protobuf::int64 timestamp_;
  ::std::string* page_group_;
  ::std::string* ab_test_;
  ::google::protobuf::RepeatedPtrField< ::std::string> custom_dimensions_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData* api_network_request_data_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData* api_custom_timer_data_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData* api_custom_metric_data_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppLaunchData* app_launch_data_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppInactiveData* app_inactive_data_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppCrashData* app_crash_data_;
  int beacon_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_ClientBeaconRecord* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch_SessionInfo : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_SessionInfo();
  virtual ~ClientBeaconBatch_SessionInfo();

  ClientBeaconBatch_SessionInfo(const ClientBeaconBatch_SessionInfo& from);

  inline ClientBeaconBatch_SessionInfo& operator=(const ClientBeaconBatch_SessionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_SessionInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_SessionInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_SessionInfo* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_SessionInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_SessionInfo& from);
  void MergeFrom(const ClientBeaconBatch_SessionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int64 start_time = 2;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  inline ::google::protobuf::int64 start_time() const;
  inline void set_start_time(::google::protobuf::int64 value);

  // optional int64 end_time = 3;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 3;
  inline ::google::protobuf::int64 end_time() const;
  inline void set_end_time(::google::protobuf::int64 value);

  // optional int32 network_request_count_total = 4;
  inline bool has_network_request_count_total() const;
  inline void clear_network_request_count_total();
  static const int kNetworkRequestCountTotalFieldNumber = 4;
  inline ::google::protobuf::int32 network_request_count_total() const;
  inline void set_network_request_count_total(::google::protobuf::int32 value);

  // optional int64 network_request_duration_total = 5;
  inline bool has_network_request_duration_total() const;
  inline void clear_network_request_duration_total();
  static const int kNetworkRequestDurationTotalFieldNumber = 5;
  inline ::google::protobuf::int64 network_request_duration_total() const;
  inline void set_network_request_duration_total(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.SessionInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_network_request_count_total();
  inline void clear_has_network_request_count_total();
  inline void set_has_network_request_duration_total();
  inline void clear_has_network_request_duration_total();

  ::std::string* id_;
  ::google::protobuf::int64 start_time_;
  ::google::protobuf::int64 end_time_;
  ::google::protobuf::int64 network_request_duration_total_;
  ::google::protobuf::int32 network_request_count_total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_SessionInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch();
  virtual ~ClientBeaconBatch();

  ClientBeaconBatch(const ClientBeaconBatch& from);

  inline ClientBeaconBatch& operator=(const ClientBeaconBatch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch& from);
  void MergeFrom(const ClientBeaconBatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClientBeaconBatch_ClientBeaconBatchRecord ClientBeaconBatchRecord;
  typedef ClientBeaconBatch_ClientBeaconRecord ClientBeaconRecord;
  typedef ClientBeaconBatch_SessionInfo SessionInfo;

  typedef ClientBeaconBatch_BeaconType BeaconType;
  static const BeaconType PAGE_VIEW = ClientBeaconBatch_BeaconType_PAGE_VIEW;
  static const BeaconType MANUAL = ClientBeaconBatch_BeaconType_MANUAL;
  static const BeaconType SPA = ClientBeaconBatch_BeaconType_SPA;
  static const BeaconType SPA_HARD = ClientBeaconBatch_BeaconType_SPA_HARD;
  static const BeaconType XHR = ClientBeaconBatch_BeaconType_XHR;
  static const BeaconType CLICK = ClientBeaconBatch_BeaconType_CLICK;
  static const BeaconType API = ClientBeaconBatch_BeaconType_API;
  static const BeaconType API_NETWORK_REQUEST = ClientBeaconBatch_BeaconType_API_NETWORK_REQUEST;
  static const BeaconType API_CUSTOM_METRIC = ClientBeaconBatch_BeaconType_API_CUSTOM_METRIC;
  static const BeaconType API_CUSTOM_TIMER = ClientBeaconBatch_BeaconType_API_CUSTOM_TIMER;
  static const BeaconType APP_LAUNCH = ClientBeaconBatch_BeaconType_APP_LAUNCH;
  static const BeaconType APP_INACTIVE = ClientBeaconBatch_BeaconType_APP_INACTIVE;
  static const BeaconType APP_CRASH = ClientBeaconBatch_BeaconType_APP_CRASH;
  static const BeaconType BATCH = ClientBeaconBatch_BeaconType_BATCH;
  static inline bool BeaconType_IsValid(int value) {
    return ClientBeaconBatch_BeaconType_IsValid(value);
  }
  static const BeaconType BeaconType_MIN =
    ClientBeaconBatch_BeaconType_BeaconType_MIN;
  static const BeaconType BeaconType_MAX =
    ClientBeaconBatch_BeaconType_BeaconType_MAX;
  static const int BeaconType_ARRAYSIZE =
    ClientBeaconBatch_BeaconType_BeaconType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string boomerang_version = 1;
  inline bool has_boomerang_version() const;
  inline void clear_boomerang_version();
  static const int kBoomerangVersionFieldNumber = 1;
  inline const ::std::string& boomerang_version() const;
  inline void set_boomerang_version(const ::std::string& value);
  inline void set_boomerang_version(const char* value);
  inline void set_boomerang_version(const char* value, size_t size);
  inline ::std::string* mutable_boomerang_version();
  inline ::std::string* release_boomerang_version();
  inline void set_allocated_boomerang_version(::std::string* boomerang_version);

  // optional string domain = 2;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 2;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional string api_key = 3;
  inline bool has_api_key() const;
  inline void clear_api_key();
  static const int kApiKeyFieldNumber = 3;
  inline const ::std::string& api_key() const;
  inline void set_api_key(const ::std::string& value);
  inline void set_api_key(const char* value);
  inline void set_api_key(const char* value, size_t size);
  inline ::std::string* mutable_api_key();
  inline ::std::string* release_api_key();
  inline void set_allocated_api_key(::std::string* api_key);

  // optional string device = 4;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 4;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional string manufacturer = 5;
  inline bool has_manufacturer() const;
  inline void clear_manufacturer();
  static const int kManufacturerFieldNumber = 5;
  inline const ::std::string& manufacturer() const;
  inline void set_manufacturer(const ::std::string& value);
  inline void set_manufacturer(const char* value);
  inline void set_manufacturer(const char* value, size_t size);
  inline ::std::string* mutable_manufacturer();
  inline ::std::string* release_manufacturer();
  inline void set_allocated_manufacturer(::std::string* manufacturer);

  // optional string type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string os = 7;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 7;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string isp = 8;
  inline bool has_isp() const;
  inline void clear_isp();
  static const int kIspFieldNumber = 8;
  inline const ::std::string& isp() const;
  inline void set_isp(const ::std::string& value);
  inline void set_isp(const char* value);
  inline void set_isp(const char* value, size_t size);
  inline ::std::string* mutable_isp();
  inline ::std::string* release_isp();
  inline void set_allocated_isp(::std::string* isp);

  // optional string connection_type = 9;
  inline bool has_connection_type() const;
  inline void clear_connection_type();
  static const int kConnectionTypeFieldNumber = 9;
  inline const ::std::string& connection_type() const;
  inline void set_connection_type(const ::std::string& value);
  inline void set_connection_type(const char* value);
  inline void set_connection_type(const char* value, size_t size);
  inline ::std::string* mutable_connection_type();
  inline ::std::string* release_connection_type();
  inline void set_allocated_connection_type(::std::string* connection_type);

  // optional string site_version = 10;
  inline bool has_site_version() const;
  inline void clear_site_version();
  static const int kSiteVersionFieldNumber = 10;
  inline const ::std::string& site_version() const;
  inline void set_site_version(const ::std::string& value);
  inline void set_site_version(const char* value);
  inline void set_site_version(const char* value, size_t size);
  inline ::std::string* mutable_site_version();
  inline ::std::string* release_site_version();
  inline void set_allocated_site_version(::std::string* site_version);

  // optional float latitude = 11;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 11;
  inline float latitude() const;
  inline void set_latitude(float value);

  // optional float longitude = 12;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 12;
  inline float longitude() const;
  inline void set_longitude(float value);

  // optional .client_beacon_batch.ClientBeaconBatch.SessionInfo session = 13;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 13;
  inline const ::client_beacon_batch::ClientBeaconBatch_SessionInfo& session() const;
  inline ::client_beacon_batch::ClientBeaconBatch_SessionInfo* mutable_session();
  inline ::client_beacon_batch::ClientBeaconBatch_SessionInfo* release_session();
  inline void set_allocated_session(::client_beacon_batch::ClientBeaconBatch_SessionInfo* session);

  // repeated .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord records = 14;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 14;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord& records(int index) const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord* mutable_records(int index);
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord* add_records();
  inline const ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord >&
      records() const;
  inline ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord >*
      mutable_records();

  // repeated .client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord beacon_records = 15;
  inline int beacon_records_size() const;
  inline void clear_beacon_records();
  static const int kBeaconRecordsFieldNumber = 15;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord& beacon_records(int index) const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord* mutable_beacon_records(int index);
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord* add_beacon_records();
  inline const ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord >&
      beacon_records() const;
  inline ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord >*
      mutable_beacon_records();

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch)
 private:
  inline void set_has_boomerang_version();
  inline void clear_has_boomerang_version();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_api_key();
  inline void clear_has_api_key();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_manufacturer();
  inline void clear_has_manufacturer();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_isp();
  inline void clear_has_isp();
  inline void set_has_connection_type();
  inline void clear_has_connection_type();
  inline void set_has_site_version();
  inline void clear_has_site_version();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_session();
  inline void clear_has_session();

  ::std::string* boomerang_version_;
  ::std::string* domain_;
  ::std::string* api_key_;
  ::std::string* device_;
  ::std::string* manufacturer_;
  ::std::string* type_;
  ::std::string* os_;
  ::std::string* isp_;
  ::std::string* connection_type_;
  ::std::string* site_version_;
  float latitude_;
  float longitude_;
  ::client_beacon_batch::ClientBeaconBatch_SessionInfo* session_;
  ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord > records_;
  ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord > beacon_records_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientBeaconBatch_ClientBeaconBatchRecord_TimerData

// optional int32 total = 1;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::total() const {
  return total_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
}

// optional int32 min = 2;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::has_min() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_has_min() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_has_min() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_min() {
  min_ = 0;
  clear_has_min();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::min() const {
  return min_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_min(::google::protobuf::int32 value) {
  set_has_min();
  min_ = value;
}

// optional int32 max = 3;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::has_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_has_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_has_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::max() const {
  return max_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_max(::google::protobuf::int32 value) {
  set_has_max();
  max_ = value;
}

// optional int64 sum = 4;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::has_sum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_has_sum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_has_sum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_sum() {
  sum_ = GOOGLE_LONGLONG(0);
  clear_has_sum();
}
inline ::google::protobuf::int64 ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::sum() const {
  return sum_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_sum(::google::protobuf::int64 value) {
  set_has_sum();
  sum_ = value;
}

// optional int64 sum_sq = 5;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::has_sum_sq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_has_sum_sq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_has_sum_sq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_sum_sq() {
  sum_sq_ = GOOGLE_LONGLONG(0);
  clear_has_sum_sq();
}
inline ::google::protobuf::int64 ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::sum_sq() const {
  return sum_sq_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_sum_sq(::google::protobuf::int64 value) {
  set_has_sum_sq();
  sum_sq_ = value;
}

// optional bytes histogram = 6;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::has_histogram() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_has_histogram() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_has_histogram() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_histogram() {
  if (histogram_ != &::google::protobuf::internal::kEmptyString) {
    histogram_->clear();
  }
  clear_has_histogram();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::histogram() const {
  return *histogram_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_histogram(const ::std::string& value) {
  set_has_histogram();
  if (histogram_ == &::google::protobuf::internal::kEmptyString) {
    histogram_ = new ::std::string;
  }
  histogram_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_histogram(const char* value) {
  set_has_histogram();
  if (histogram_ == &::google::protobuf::internal::kEmptyString) {
    histogram_ = new ::std::string;
  }
  histogram_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_histogram(const void* value, size_t size) {
  set_has_histogram();
  if (histogram_ == &::google::protobuf::internal::kEmptyString) {
    histogram_ = new ::std::string;
  }
  histogram_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::mutable_histogram() {
  set_has_histogram();
  if (histogram_ == &::google::protobuf::internal::kEmptyString) {
    histogram_ = new ::std::string;
  }
  return histogram_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::release_histogram() {
  clear_has_histogram();
  if (histogram_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = histogram_;
    histogram_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_allocated_histogram(::std::string* histogram) {
  if (histogram_ != &::google::protobuf::internal::kEmptyString) {
    delete histogram_;
  }
  if (histogram) {
    set_has_histogram();
    histogram_ = histogram;
  } else {
    clear_has_histogram();
    histogram_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData request_duration_timer = 1;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::has_request_duration_timer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_has_request_duration_timer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_has_request_duration_timer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_request_duration_timer() {
  if (request_duration_timer_ != NULL) request_duration_timer_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::Clear();
  clear_has_request_duration_timer();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::request_duration_timer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return request_duration_timer_ != NULL ? *request_duration_timer_ : *default_instance().request_duration_timer_;
#else
  return request_duration_timer_ != NULL ? *request_duration_timer_ : *default_instance_->request_duration_timer_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::mutable_request_duration_timer() {
  set_has_request_duration_timer();
  if (request_duration_timer_ == NULL) request_duration_timer_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData;
  return request_duration_timer_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::release_request_duration_timer() {
  clear_has_request_duration_timer();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* temp = request_duration_timer_;
  request_duration_timer_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_allocated_request_duration_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* request_duration_timer) {
  delete request_duration_timer_;
  request_duration_timer_ = request_duration_timer;
  if (request_duration_timer) {
    set_has_request_duration_timer();
  } else {
    clear_has_request_duration_timer();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData dns_timer = 2;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::has_dns_timer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_has_dns_timer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_has_dns_timer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_dns_timer() {
  if (dns_timer_ != NULL) dns_timer_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::Clear();
  clear_has_dns_timer();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::dns_timer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dns_timer_ != NULL ? *dns_timer_ : *default_instance().dns_timer_;
#else
  return dns_timer_ != NULL ? *dns_timer_ : *default_instance_->dns_timer_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::mutable_dns_timer() {
  set_has_dns_timer();
  if (dns_timer_ == NULL) dns_timer_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData;
  return dns_timer_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::release_dns_timer() {
  clear_has_dns_timer();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* temp = dns_timer_;
  dns_timer_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_allocated_dns_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* dns_timer) {
  delete dns_timer_;
  dns_timer_ = dns_timer;
  if (dns_timer) {
    set_has_dns_timer();
  } else {
    clear_has_dns_timer();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData tcp_timer = 3;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::has_tcp_timer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_has_tcp_timer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_has_tcp_timer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_tcp_timer() {
  if (tcp_timer_ != NULL) tcp_timer_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::Clear();
  clear_has_tcp_timer();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::tcp_timer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tcp_timer_ != NULL ? *tcp_timer_ : *default_instance().tcp_timer_;
#else
  return tcp_timer_ != NULL ? *tcp_timer_ : *default_instance_->tcp_timer_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::mutable_tcp_timer() {
  set_has_tcp_timer();
  if (tcp_timer_ == NULL) tcp_timer_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData;
  return tcp_timer_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::release_tcp_timer() {
  clear_has_tcp_timer();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* temp = tcp_timer_;
  tcp_timer_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_allocated_tcp_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* tcp_timer) {
  delete tcp_timer_;
  tcp_timer_ = tcp_timer;
  if (tcp_timer) {
    set_has_tcp_timer();
  } else {
    clear_has_tcp_timer();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData ssl_timer = 4;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::has_ssl_timer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_has_ssl_timer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_has_ssl_timer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_ssl_timer() {
  if (ssl_timer_ != NULL) ssl_timer_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::Clear();
  clear_has_ssl_timer();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::ssl_timer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ssl_timer_ != NULL ? *ssl_timer_ : *default_instance().ssl_timer_;
#else
  return ssl_timer_ != NULL ? *ssl_timer_ : *default_instance_->ssl_timer_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::mutable_ssl_timer() {
  set_has_ssl_timer();
  if (ssl_timer_ == NULL) ssl_timer_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData;
  return ssl_timer_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::release_ssl_timer() {
  clear_has_ssl_timer();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* temp = ssl_timer_;
  ssl_timer_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_allocated_ssl_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ssl_timer) {
  delete ssl_timer_;
  ssl_timer_ = ssl_timer;
  if (ssl_timer) {
    set_has_ssl_timer();
  } else {
    clear_has_ssl_timer();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData time_to_first_byte_timer = 5;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::has_time_to_first_byte_timer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_has_time_to_first_byte_timer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_has_time_to_first_byte_timer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_time_to_first_byte_timer() {
  if (time_to_first_byte_timer_ != NULL) time_to_first_byte_timer_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::Clear();
  clear_has_time_to_first_byte_timer();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::time_to_first_byte_timer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return time_to_first_byte_timer_ != NULL ? *time_to_first_byte_timer_ : *default_instance().time_to_first_byte_timer_;
#else
  return time_to_first_byte_timer_ != NULL ? *time_to_first_byte_timer_ : *default_instance_->time_to_first_byte_timer_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::mutable_time_to_first_byte_timer() {
  set_has_time_to_first_byte_timer();
  if (time_to_first_byte_timer_ == NULL) time_to_first_byte_timer_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData;
  return time_to_first_byte_timer_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::release_time_to_first_byte_timer() {
  clear_has_time_to_first_byte_timer();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* temp = time_to_first_byte_timer_;
  time_to_first_byte_timer_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_allocated_time_to_first_byte_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* time_to_first_byte_timer) {
  delete time_to_first_byte_timer_;
  time_to_first_byte_timer_ = time_to_first_byte_timer;
  if (time_to_first_byte_timer) {
    set_has_time_to_first_byte_timer();
  } else {
    clear_has_time_to_first_byte_timer();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData time_to_last_byte_timer = 6;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::has_time_to_last_byte_timer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_has_time_to_last_byte_timer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_has_time_to_last_byte_timer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_time_to_last_byte_timer() {
  if (time_to_last_byte_timer_ != NULL) time_to_last_byte_timer_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::Clear();
  clear_has_time_to_last_byte_timer();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::time_to_last_byte_timer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return time_to_last_byte_timer_ != NULL ? *time_to_last_byte_timer_ : *default_instance().time_to_last_byte_timer_;
#else
  return time_to_last_byte_timer_ != NULL ? *time_to_last_byte_timer_ : *default_instance_->time_to_last_byte_timer_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::mutable_time_to_last_byte_timer() {
  set_has_time_to_last_byte_timer();
  if (time_to_last_byte_timer_ == NULL) time_to_last_byte_timer_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData;
  return time_to_last_byte_timer_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::release_time_to_last_byte_timer() {
  clear_has_time_to_last_byte_timer();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* temp = time_to_last_byte_timer_;
  time_to_last_byte_timer_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_allocated_time_to_last_byte_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* time_to_last_byte_timer) {
  delete time_to_last_byte_timer_;
  time_to_last_byte_timer_ = time_to_last_byte_timer;
  if (time_to_last_byte_timer) {
    set_has_time_to_last_byte_timer();
  } else {
    clear_has_time_to_last_byte_timer();
  }
}

// -------------------------------------------------------------------

// ClientBeaconBatch_ClientBeaconBatchRecord

// optional string page_group = 1;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_page_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_page_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_page_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_page_group() {
  if (page_group_ != &::google::protobuf::internal::kEmptyString) {
    page_group_->clear();
  }
  clear_has_page_group();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconBatchRecord::page_group() const {
  return *page_group_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_page_group(const ::std::string& value) {
  set_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    page_group_ = new ::std::string;
  }
  page_group_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_page_group(const char* value) {
  set_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    page_group_ = new ::std::string;
  }
  page_group_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_page_group(const char* value, size_t size) {
  set_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    page_group_ = new ::std::string;
  }
  page_group_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::mutable_page_group() {
  set_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    page_group_ = new ::std::string;
  }
  return page_group_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::release_page_group() {
  clear_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = page_group_;
    page_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_allocated_page_group(::std::string* page_group) {
  if (page_group_ != &::google::protobuf::internal::kEmptyString) {
    delete page_group_;
  }
  if (page_group) {
    set_has_page_group();
    page_group_ = page_group;
  } else {
    clear_has_page_group();
    page_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ab_test = 2;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_ab_test() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_ab_test() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_ab_test() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_ab_test() {
  if (ab_test_ != &::google::protobuf::internal::kEmptyString) {
    ab_test_->clear();
  }
  clear_has_ab_test();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconBatchRecord::ab_test() const {
  return *ab_test_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_ab_test(const ::std::string& value) {
  set_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    ab_test_ = new ::std::string;
  }
  ab_test_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_ab_test(const char* value) {
  set_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    ab_test_ = new ::std::string;
  }
  ab_test_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_ab_test(const char* value, size_t size) {
  set_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    ab_test_ = new ::std::string;
  }
  ab_test_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::mutable_ab_test() {
  set_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    ab_test_ = new ::std::string;
  }
  return ab_test_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::release_ab_test() {
  clear_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ab_test_;
    ab_test_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_allocated_ab_test(::std::string* ab_test) {
  if (ab_test_ != &::google::protobuf::internal::kEmptyString) {
    delete ab_test_;
  }
  if (ab_test) {
    set_has_ab_test();
    ab_test_ = ab_test;
  } else {
    clear_has_ab_test();
    ab_test_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string url = 3;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconBatchRecord::url() const {
  return *url_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 network_error_code = 4;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_network_error_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_network_error_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_network_error_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_network_error_code() {
  network_error_code_ = 0;
  clear_has_network_error_code();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconBatchRecord::network_error_code() const {
  return network_error_code_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_network_error_code(::google::protobuf::int32 value) {
  set_has_network_error_code();
  network_error_code_ = value;
}

// optional int64 timestamp = 5;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 ClientBeaconBatch_ClientBeaconBatchRecord::timestamp() const {
  return timestamp_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.NetworkTimers network_timers = 6;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_network_timers() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_network_timers() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_network_timers() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_network_timers() {
  if (network_timers_ != NULL) network_timers_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::Clear();
  clear_has_network_timers();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& ClientBeaconBatch_ClientBeaconBatchRecord::network_timers() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return network_timers_ != NULL ? *network_timers_ : *default_instance().network_timers_;
#else
  return network_timers_ != NULL ? *network_timers_ : *default_instance_->network_timers_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* ClientBeaconBatch_ClientBeaconBatchRecord::mutable_network_timers() {
  set_has_network_timers();
  if (network_timers_ == NULL) network_timers_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers;
  return network_timers_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* ClientBeaconBatch_ClientBeaconBatchRecord::release_network_timers() {
  clear_has_network_timers();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* temp = network_timers_;
  network_timers_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_allocated_network_timers(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* network_timers) {
  delete network_timers_;
  network_timers_ = network_timers;
  if (network_timers) {
    set_has_network_timers();
  } else {
    clear_has_network_timers();
  }
}

// repeated .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData custom_timers = 7;
inline int ClientBeaconBatch_ClientBeaconBatchRecord::custom_timers_size() const {
  return custom_timers_.size();
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_custom_timers() {
  custom_timers_.Clear();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ClientBeaconBatch_ClientBeaconBatchRecord::custom_timers(int index) const {
  return custom_timers_.Get(index);
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord::mutable_custom_timers(int index) {
  return custom_timers_.Mutable(index);
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord::add_custom_timers() {
  return custom_timers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData >&
ClientBeaconBatch_ClientBeaconBatchRecord::custom_timers() const {
  return custom_timers_;
}
inline ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData >*
ClientBeaconBatch_ClientBeaconBatchRecord::mutable_custom_timers() {
  return &custom_timers_;
}

// repeated int64 custom_metrics = 8;
inline int ClientBeaconBatch_ClientBeaconBatchRecord::custom_metrics_size() const {
  return custom_metrics_.size();
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_custom_metrics() {
  custom_metrics_.Clear();
}
inline ::google::protobuf::int64 ClientBeaconBatch_ClientBeaconBatchRecord::custom_metrics(int index) const {
  return custom_metrics_.Get(index);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_custom_metrics(int index, ::google::protobuf::int64 value) {
  custom_metrics_.Set(index, value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::add_custom_metrics(::google::protobuf::int64 value) {
  custom_metrics_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ClientBeaconBatch_ClientBeaconBatchRecord::custom_metrics() const {
  return custom_metrics_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ClientBeaconBatch_ClientBeaconBatchRecord::mutable_custom_metrics() {
  return &custom_metrics_;
}

// optional int32 beacon_total = 9;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_beacon_total() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_beacon_total() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_beacon_total() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_beacon_total() {
  beacon_total_ = 0;
  clear_has_beacon_total();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconBatchRecord::beacon_total() const {
  return beacon_total_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_beacon_total(::google::protobuf::int32 value) {
  set_has_beacon_total();
  beacon_total_ = value;
}

// optional int32 crashes_total = 10;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_crashes_total() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_crashes_total() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_crashes_total() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_crashes_total() {
  crashes_total_ = 0;
  clear_has_crashes_total();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconBatchRecord::crashes_total() const {
  return crashes_total_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_crashes_total(::google::protobuf::int32 value) {
  set_has_crashes_total();
  crashes_total_ = value;
}

// optional int32 installs_total = 11;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_installs_total() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_installs_total() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_installs_total() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_installs_total() {
  installs_total_ = 0;
  clear_has_installs_total();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconBatchRecord::installs_total() const {
  return installs_total_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_installs_total(::google::protobuf::int32 value) {
  set_has_installs_total();
  installs_total_ = value;
}

// repeated string custom_dimensions = 12;
inline int ClientBeaconBatch_ClientBeaconBatchRecord::custom_dimensions_size() const {
  return custom_dimensions_.size();
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_custom_dimensions() {
  custom_dimensions_.Clear();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconBatchRecord::custom_dimensions(int index) const {
  return custom_dimensions_.Get(index);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::mutable_custom_dimensions(int index) {
  return custom_dimensions_.Mutable(index);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_custom_dimensions(int index, const ::std::string& value) {
  custom_dimensions_.Mutable(index)->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_custom_dimensions(int index, const char* value) {
  custom_dimensions_.Mutable(index)->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_custom_dimensions(int index, const char* value, size_t size) {
  custom_dimensions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::add_custom_dimensions() {
  return custom_dimensions_.Add();
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::add_custom_dimensions(const ::std::string& value) {
  custom_dimensions_.Add()->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::add_custom_dimensions(const char* value) {
  custom_dimensions_.Add()->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::add_custom_dimensions(const char* value, size_t size) {
  custom_dimensions_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClientBeaconBatch_ClientBeaconBatchRecord::custom_dimensions() const {
  return custom_dimensions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClientBeaconBatch_ClientBeaconBatchRecord::mutable_custom_dimensions() {
  return &custom_dimensions_;
}

// optional string beacon_type = 13;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_beacon_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_beacon_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_beacon_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_beacon_type() {
  if (beacon_type_ != &::google::protobuf::internal::kEmptyString) {
    beacon_type_->clear();
  }
  clear_has_beacon_type();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconBatchRecord::beacon_type() const {
  return *beacon_type_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_beacon_type(const ::std::string& value) {
  set_has_beacon_type();
  if (beacon_type_ == &::google::protobuf::internal::kEmptyString) {
    beacon_type_ = new ::std::string;
  }
  beacon_type_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_beacon_type(const char* value) {
  set_has_beacon_type();
  if (beacon_type_ == &::google::protobuf::internal::kEmptyString) {
    beacon_type_ = new ::std::string;
  }
  beacon_type_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_beacon_type(const char* value, size_t size) {
  set_has_beacon_type();
  if (beacon_type_ == &::google::protobuf::internal::kEmptyString) {
    beacon_type_ = new ::std::string;
  }
  beacon_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::mutable_beacon_type() {
  set_has_beacon_type();
  if (beacon_type_ == &::google::protobuf::internal::kEmptyString) {
    beacon_type_ = new ::std::string;
  }
  return beacon_type_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::release_beacon_type() {
  clear_has_beacon_type();
  if (beacon_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = beacon_type_;
    beacon_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_allocated_beacon_type(::std::string* beacon_type) {
  if (beacon_type_ != &::google::protobuf::internal::kEmptyString) {
    delete beacon_type_;
  }
  if (beacon_type) {
    set_has_beacon_type();
    beacon_type_ = beacon_type;
  } else {
    clear_has_beacon_type();
    beacon_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData

// optional int32 duration = 1;
inline bool ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::has_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_has_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::clear_has_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::duration() const {
  return duration_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
}

// optional string url = 2;
inline bool ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::url() const {
  return *url_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 network_error_code = 3;
inline bool ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::has_network_error_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_has_network_error_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::clear_has_network_error_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::clear_network_error_code() {
  network_error_code_ = 0;
  clear_has_network_error_code();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::network_error_code() const {
  return network_error_code_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_network_error_code(::google::protobuf::int32 value) {
  set_has_network_error_code();
  network_error_code_ = value;
}

// optional int32 dns = 4;
inline bool ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::has_dns() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_has_dns() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::clear_has_dns() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::clear_dns() {
  dns_ = 0;
  clear_has_dns();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::dns() const {
  return dns_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_dns(::google::protobuf::int32 value) {
  set_has_dns();
  dns_ = value;
}

// optional int32 tcp = 5;
inline bool ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::has_tcp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_has_tcp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::clear_has_tcp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::clear_tcp() {
  tcp_ = 0;
  clear_has_tcp();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::tcp() const {
  return tcp_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_tcp(::google::protobuf::int32 value) {
  set_has_tcp();
  tcp_ = value;
}

// optional int32 ssl = 6;
inline bool ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::has_ssl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_has_ssl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::clear_has_ssl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::clear_ssl() {
  ssl_ = 0;
  clear_has_ssl();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::ssl() const {
  return ssl_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_ssl(::google::protobuf::int32 value) {
  set_has_ssl();
  ssl_ = value;
}

// optional int32 ttfb = 7;
inline bool ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::has_ttfb() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_has_ttfb() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::clear_has_ttfb() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::clear_ttfb() {
  ttfb_ = 0;
  clear_has_ttfb();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::ttfb() const {
  return ttfb_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::set_ttfb(::google::protobuf::int32 value) {
  set_has_ttfb();
  ttfb_ = value;
}

// -------------------------------------------------------------------

// ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData

// optional int32 timer_value = 1;
inline bool ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData::has_timer_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData::set_has_timer_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData::clear_has_timer_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData::clear_timer_value() {
  timer_value_ = 0;
  clear_has_timer_value();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData::timer_value() const {
  return timer_value_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData::set_timer_value(::google::protobuf::int32 value) {
  set_has_timer_value();
  timer_value_ = value;
}

// optional int32 timer_index = 2;
inline bool ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData::has_timer_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData::set_has_timer_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData::clear_has_timer_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData::clear_timer_index() {
  timer_index_ = 0;
  clear_has_timer_index();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData::timer_index() const {
  return timer_index_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData::set_timer_index(::google::protobuf::int32 value) {
  set_has_timer_index();
  timer_index_ = value;
}

// -------------------------------------------------------------------

// ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData

// optional int32 metric_value = 1;
inline bool ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData::has_metric_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData::set_has_metric_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData::clear_has_metric_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData::clear_metric_value() {
  metric_value_ = 0;
  clear_has_metric_value();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData::metric_value() const {
  return metric_value_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData::set_metric_value(::google::protobuf::int32 value) {
  set_has_metric_value();
  metric_value_ = value;
}

// optional int32 metric_index = 2;
inline bool ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData::has_metric_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData::set_has_metric_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData::clear_has_metric_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData::clear_metric_index() {
  metric_index_ = 0;
  clear_has_metric_index();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData::metric_index() const {
  return metric_index_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData::set_metric_index(::google::protobuf::int32 value) {
  set_has_metric_index();
  metric_index_ = value;
}

// -------------------------------------------------------------------

// ClientBeaconBatch_ClientBeaconRecord_AppLaunchData

// optional bool is_first_install = 1;
inline bool ClientBeaconBatch_ClientBeaconRecord_AppLaunchData::has_is_first_install() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppLaunchData::set_has_is_first_install() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppLaunchData::clear_has_is_first_install() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppLaunchData::clear_is_first_install() {
  is_first_install_ = false;
  clear_has_is_first_install();
}
inline bool ClientBeaconBatch_ClientBeaconRecord_AppLaunchData::is_first_install() const {
  return is_first_install_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppLaunchData::set_is_first_install(bool value) {
  set_has_is_first_install();
  is_first_install_ = value;
}

// -------------------------------------------------------------------

// ClientBeaconBatch_ClientBeaconRecord_AppInactiveData

// -------------------------------------------------------------------

// ClientBeaconBatch_ClientBeaconRecord_AppCrashData

// optional int32 code = 1;
inline bool ClientBeaconBatch_ClientBeaconRecord_AppCrashData::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconRecord_AppCrashData::code() const {
  return code_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string message = 2;
inline bool ClientBeaconBatch_ClientBeaconRecord_AppCrashData::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconRecord_AppCrashData::message() const {
  return *message_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord_AppCrashData::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord_AppCrashData::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string function = 3;
inline bool ClientBeaconBatch_ClientBeaconRecord_AppCrashData::has_function() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_has_function() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::clear_has_function() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::clear_function() {
  if (function_ != &::google::protobuf::internal::kEmptyString) {
    function_->clear();
  }
  clear_has_function();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconRecord_AppCrashData::function() const {
  return *function_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_function(const ::std::string& value) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::kEmptyString) {
    function_ = new ::std::string;
  }
  function_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_function(const char* value) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::kEmptyString) {
    function_ = new ::std::string;
  }
  function_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_function(const char* value, size_t size) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::kEmptyString) {
    function_ = new ::std::string;
  }
  function_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord_AppCrashData::mutable_function() {
  set_has_function();
  if (function_ == &::google::protobuf::internal::kEmptyString) {
    function_ = new ::std::string;
  }
  return function_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord_AppCrashData::release_function() {
  clear_has_function();
  if (function_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = function_;
    function_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_allocated_function(::std::string* function) {
  if (function_ != &::google::protobuf::internal::kEmptyString) {
    delete function_;
  }
  if (function) {
    set_has_function();
    function_ = function;
  } else {
    clear_has_function();
    function_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string file = 4;
inline bool ClientBeaconBatch_ClientBeaconRecord_AppCrashData::has_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_has_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::clear_has_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::clear_file() {
  if (file_ != &::google::protobuf::internal::kEmptyString) {
    file_->clear();
  }
  clear_has_file();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconRecord_AppCrashData::file() const {
  return *file_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_file(const ::std::string& value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_file(const char* value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_file(const char* value, size_t size) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord_AppCrashData::mutable_file() {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  return file_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord_AppCrashData::release_file() {
  clear_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_;
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_allocated_file(::std::string* file) {
  if (file_ != &::google::protobuf::internal::kEmptyString) {
    delete file_;
  }
  if (file) {
    set_has_file();
    file_ = file;
  } else {
    clear_has_file();
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 line = 5;
inline bool ClientBeaconBatch_ClientBeaconRecord_AppCrashData::has_line() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_has_line() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::clear_has_line() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::clear_line() {
  line_ = 0;
  clear_has_line();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconRecord_AppCrashData::line() const {
  return line_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_line(::google::protobuf::int32 value) {
  set_has_line();
  line_ = value;
}

// optional int32 character = 6;
inline bool ClientBeaconBatch_ClientBeaconRecord_AppCrashData::has_character() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_has_character() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::clear_has_character() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::clear_character() {
  character_ = 0;
  clear_has_character();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconRecord_AppCrashData::character() const {
  return character_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_character(::google::protobuf::int32 value) {
  set_has_character();
  character_ = value;
}

// optional string stack = 7;
inline bool ClientBeaconBatch_ClientBeaconRecord_AppCrashData::has_stack() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_has_stack() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::clear_has_stack() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::clear_stack() {
  if (stack_ != &::google::protobuf::internal::kEmptyString) {
    stack_->clear();
  }
  clear_has_stack();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconRecord_AppCrashData::stack() const {
  return *stack_;
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_stack(const ::std::string& value) {
  set_has_stack();
  if (stack_ == &::google::protobuf::internal::kEmptyString) {
    stack_ = new ::std::string;
  }
  stack_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_stack(const char* value) {
  set_has_stack();
  if (stack_ == &::google::protobuf::internal::kEmptyString) {
    stack_ = new ::std::string;
  }
  stack_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_stack(const char* value, size_t size) {
  set_has_stack();
  if (stack_ == &::google::protobuf::internal::kEmptyString) {
    stack_ = new ::std::string;
  }
  stack_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord_AppCrashData::mutable_stack() {
  set_has_stack();
  if (stack_ == &::google::protobuf::internal::kEmptyString) {
    stack_ = new ::std::string;
  }
  return stack_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord_AppCrashData::release_stack() {
  clear_has_stack();
  if (stack_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stack_;
    stack_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconRecord_AppCrashData::set_allocated_stack(::std::string* stack) {
  if (stack_ != &::google::protobuf::internal::kEmptyString) {
    delete stack_;
  }
  if (stack) {
    set_has_stack();
    stack_ = stack;
  } else {
    clear_has_stack();
    stack_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientBeaconBatch_ClientBeaconRecord

// optional int64 timestamp = 1;
inline bool ClientBeaconBatch_ClientBeaconRecord::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 ClientBeaconBatch_ClientBeaconRecord::timestamp() const {
  return timestamp_;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .client_beacon_batch.ClientBeaconBatch.BeaconType beacon_type = 2;
inline bool ClientBeaconBatch_ClientBeaconRecord::has_beacon_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_has_beacon_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_has_beacon_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_beacon_type() {
  beacon_type_ = 0;
  clear_has_beacon_type();
}
inline ::client_beacon_batch::ClientBeaconBatch_BeaconType ClientBeaconBatch_ClientBeaconRecord::beacon_type() const {
  return static_cast< ::client_beacon_batch::ClientBeaconBatch_BeaconType >(beacon_type_);
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_beacon_type(::client_beacon_batch::ClientBeaconBatch_BeaconType value) {
  assert(::client_beacon_batch::ClientBeaconBatch_BeaconType_IsValid(value));
  set_has_beacon_type();
  beacon_type_ = value;
}

// optional string page_group = 3;
inline bool ClientBeaconBatch_ClientBeaconRecord::has_page_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_has_page_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_has_page_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_page_group() {
  if (page_group_ != &::google::protobuf::internal::kEmptyString) {
    page_group_->clear();
  }
  clear_has_page_group();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconRecord::page_group() const {
  return *page_group_;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_page_group(const ::std::string& value) {
  set_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    page_group_ = new ::std::string;
  }
  page_group_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_page_group(const char* value) {
  set_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    page_group_ = new ::std::string;
  }
  page_group_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_page_group(const char* value, size_t size) {
  set_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    page_group_ = new ::std::string;
  }
  page_group_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord::mutable_page_group() {
  set_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    page_group_ = new ::std::string;
  }
  return page_group_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord::release_page_group() {
  clear_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = page_group_;
    page_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_allocated_page_group(::std::string* page_group) {
  if (page_group_ != &::google::protobuf::internal::kEmptyString) {
    delete page_group_;
  }
  if (page_group) {
    set_has_page_group();
    page_group_ = page_group;
  } else {
    clear_has_page_group();
    page_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ab_test = 4;
inline bool ClientBeaconBatch_ClientBeaconRecord::has_ab_test() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_has_ab_test() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_has_ab_test() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_ab_test() {
  if (ab_test_ != &::google::protobuf::internal::kEmptyString) {
    ab_test_->clear();
  }
  clear_has_ab_test();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconRecord::ab_test() const {
  return *ab_test_;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_ab_test(const ::std::string& value) {
  set_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    ab_test_ = new ::std::string;
  }
  ab_test_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_ab_test(const char* value) {
  set_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    ab_test_ = new ::std::string;
  }
  ab_test_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_ab_test(const char* value, size_t size) {
  set_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    ab_test_ = new ::std::string;
  }
  ab_test_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord::mutable_ab_test() {
  set_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    ab_test_ = new ::std::string;
  }
  return ab_test_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord::release_ab_test() {
  clear_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ab_test_;
    ab_test_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_allocated_ab_test(::std::string* ab_test) {
  if (ab_test_ != &::google::protobuf::internal::kEmptyString) {
    delete ab_test_;
  }
  if (ab_test) {
    set_has_ab_test();
    ab_test_ = ab_test;
  } else {
    clear_has_ab_test();
    ab_test_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string custom_dimensions = 5;
inline int ClientBeaconBatch_ClientBeaconRecord::custom_dimensions_size() const {
  return custom_dimensions_.size();
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_custom_dimensions() {
  custom_dimensions_.Clear();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconRecord::custom_dimensions(int index) const {
  return custom_dimensions_.Get(index);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord::mutable_custom_dimensions(int index) {
  return custom_dimensions_.Mutable(index);
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_custom_dimensions(int index, const ::std::string& value) {
  custom_dimensions_.Mutable(index)->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_custom_dimensions(int index, const char* value) {
  custom_dimensions_.Mutable(index)->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_custom_dimensions(int index, const char* value, size_t size) {
  custom_dimensions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconRecord::add_custom_dimensions() {
  return custom_dimensions_.Add();
}
inline void ClientBeaconBatch_ClientBeaconRecord::add_custom_dimensions(const ::std::string& value) {
  custom_dimensions_.Add()->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord::add_custom_dimensions(const char* value) {
  custom_dimensions_.Add()->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconRecord::add_custom_dimensions(const char* value, size_t size) {
  custom_dimensions_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClientBeaconBatch_ClientBeaconRecord::custom_dimensions() const {
  return custom_dimensions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClientBeaconBatch_ClientBeaconRecord::mutable_custom_dimensions() {
  return &custom_dimensions_;
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.ApiNetworkRequestData api_network_request_data = 6;
inline bool ClientBeaconBatch_ClientBeaconRecord::has_api_network_request_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_has_api_network_request_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_has_api_network_request_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_api_network_request_data() {
  if (api_network_request_data_ != NULL) api_network_request_data_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData::Clear();
  clear_has_api_network_request_data();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData& ClientBeaconBatch_ClientBeaconRecord::api_network_request_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return api_network_request_data_ != NULL ? *api_network_request_data_ : *default_instance().api_network_request_data_;
#else
  return api_network_request_data_ != NULL ? *api_network_request_data_ : *default_instance_->api_network_request_data_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData* ClientBeaconBatch_ClientBeaconRecord::mutable_api_network_request_data() {
  set_has_api_network_request_data();
  if (api_network_request_data_ == NULL) api_network_request_data_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData;
  return api_network_request_data_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData* ClientBeaconBatch_ClientBeaconRecord::release_api_network_request_data() {
  clear_has_api_network_request_data();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData* temp = api_network_request_data_;
  api_network_request_data_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_allocated_api_network_request_data(::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiNetworkRequestData* api_network_request_data) {
  delete api_network_request_data_;
  api_network_request_data_ = api_network_request_data;
  if (api_network_request_data) {
    set_has_api_network_request_data();
  } else {
    clear_has_api_network_request_data();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.ApiCustomTimerData api_custom_timer_data = 7;
inline bool ClientBeaconBatch_ClientBeaconRecord::has_api_custom_timer_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_has_api_custom_timer_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_has_api_custom_timer_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_api_custom_timer_data() {
  if (api_custom_timer_data_ != NULL) api_custom_timer_data_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData::Clear();
  clear_has_api_custom_timer_data();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData& ClientBeaconBatch_ClientBeaconRecord::api_custom_timer_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return api_custom_timer_data_ != NULL ? *api_custom_timer_data_ : *default_instance().api_custom_timer_data_;
#else
  return api_custom_timer_data_ != NULL ? *api_custom_timer_data_ : *default_instance_->api_custom_timer_data_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData* ClientBeaconBatch_ClientBeaconRecord::mutable_api_custom_timer_data() {
  set_has_api_custom_timer_data();
  if (api_custom_timer_data_ == NULL) api_custom_timer_data_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData;
  return api_custom_timer_data_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData* ClientBeaconBatch_ClientBeaconRecord::release_api_custom_timer_data() {
  clear_has_api_custom_timer_data();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData* temp = api_custom_timer_data_;
  api_custom_timer_data_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_allocated_api_custom_timer_data(::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomTimerData* api_custom_timer_data) {
  delete api_custom_timer_data_;
  api_custom_timer_data_ = api_custom_timer_data;
  if (api_custom_timer_data) {
    set_has_api_custom_timer_data();
  } else {
    clear_has_api_custom_timer_data();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.ApiCustomMetricData api_custom_metric_data = 8;
inline bool ClientBeaconBatch_ClientBeaconRecord::has_api_custom_metric_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_has_api_custom_metric_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_has_api_custom_metric_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_api_custom_metric_data() {
  if (api_custom_metric_data_ != NULL) api_custom_metric_data_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData::Clear();
  clear_has_api_custom_metric_data();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData& ClientBeaconBatch_ClientBeaconRecord::api_custom_metric_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return api_custom_metric_data_ != NULL ? *api_custom_metric_data_ : *default_instance().api_custom_metric_data_;
#else
  return api_custom_metric_data_ != NULL ? *api_custom_metric_data_ : *default_instance_->api_custom_metric_data_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData* ClientBeaconBatch_ClientBeaconRecord::mutable_api_custom_metric_data() {
  set_has_api_custom_metric_data();
  if (api_custom_metric_data_ == NULL) api_custom_metric_data_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData;
  return api_custom_metric_data_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData* ClientBeaconBatch_ClientBeaconRecord::release_api_custom_metric_data() {
  clear_has_api_custom_metric_data();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData* temp = api_custom_metric_data_;
  api_custom_metric_data_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_allocated_api_custom_metric_data(::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_ApiCustomMetricData* api_custom_metric_data) {
  delete api_custom_metric_data_;
  api_custom_metric_data_ = api_custom_metric_data;
  if (api_custom_metric_data) {
    set_has_api_custom_metric_data();
  } else {
    clear_has_api_custom_metric_data();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.AppLaunchData app_launch_data = 9;
inline bool ClientBeaconBatch_ClientBeaconRecord::has_app_launch_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_has_app_launch_data() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_has_app_launch_data() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_app_launch_data() {
  if (app_launch_data_ != NULL) app_launch_data_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppLaunchData::Clear();
  clear_has_app_launch_data();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppLaunchData& ClientBeaconBatch_ClientBeaconRecord::app_launch_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return app_launch_data_ != NULL ? *app_launch_data_ : *default_instance().app_launch_data_;
#else
  return app_launch_data_ != NULL ? *app_launch_data_ : *default_instance_->app_launch_data_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppLaunchData* ClientBeaconBatch_ClientBeaconRecord::mutable_app_launch_data() {
  set_has_app_launch_data();
  if (app_launch_data_ == NULL) app_launch_data_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppLaunchData;
  return app_launch_data_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppLaunchData* ClientBeaconBatch_ClientBeaconRecord::release_app_launch_data() {
  clear_has_app_launch_data();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppLaunchData* temp = app_launch_data_;
  app_launch_data_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_allocated_app_launch_data(::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppLaunchData* app_launch_data) {
  delete app_launch_data_;
  app_launch_data_ = app_launch_data;
  if (app_launch_data) {
    set_has_app_launch_data();
  } else {
    clear_has_app_launch_data();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.AppInactiveData app_inactive_data = 10;
inline bool ClientBeaconBatch_ClientBeaconRecord::has_app_inactive_data() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_has_app_inactive_data() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_has_app_inactive_data() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_app_inactive_data() {
  if (app_inactive_data_ != NULL) app_inactive_data_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppInactiveData::Clear();
  clear_has_app_inactive_data();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppInactiveData& ClientBeaconBatch_ClientBeaconRecord::app_inactive_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return app_inactive_data_ != NULL ? *app_inactive_data_ : *default_instance().app_inactive_data_;
#else
  return app_inactive_data_ != NULL ? *app_inactive_data_ : *default_instance_->app_inactive_data_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppInactiveData* ClientBeaconBatch_ClientBeaconRecord::mutable_app_inactive_data() {
  set_has_app_inactive_data();
  if (app_inactive_data_ == NULL) app_inactive_data_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppInactiveData;
  return app_inactive_data_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppInactiveData* ClientBeaconBatch_ClientBeaconRecord::release_app_inactive_data() {
  clear_has_app_inactive_data();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppInactiveData* temp = app_inactive_data_;
  app_inactive_data_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_allocated_app_inactive_data(::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppInactiveData* app_inactive_data) {
  delete app_inactive_data_;
  app_inactive_data_ = app_inactive_data;
  if (app_inactive_data) {
    set_has_app_inactive_data();
  } else {
    clear_has_app_inactive_data();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord.AppCrashData app_crash_data = 11;
inline bool ClientBeaconBatch_ClientBeaconRecord::has_app_crash_data() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_has_app_crash_data() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_has_app_crash_data() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientBeaconBatch_ClientBeaconRecord::clear_app_crash_data() {
  if (app_crash_data_ != NULL) app_crash_data_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppCrashData::Clear();
  clear_has_app_crash_data();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppCrashData& ClientBeaconBatch_ClientBeaconRecord::app_crash_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return app_crash_data_ != NULL ? *app_crash_data_ : *default_instance().app_crash_data_;
#else
  return app_crash_data_ != NULL ? *app_crash_data_ : *default_instance_->app_crash_data_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppCrashData* ClientBeaconBatch_ClientBeaconRecord::mutable_app_crash_data() {
  set_has_app_crash_data();
  if (app_crash_data_ == NULL) app_crash_data_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppCrashData;
  return app_crash_data_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppCrashData* ClientBeaconBatch_ClientBeaconRecord::release_app_crash_data() {
  clear_has_app_crash_data();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppCrashData* temp = app_crash_data_;
  app_crash_data_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconRecord::set_allocated_app_crash_data(::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord_AppCrashData* app_crash_data) {
  delete app_crash_data_;
  app_crash_data_ = app_crash_data;
  if (app_crash_data) {
    set_has_app_crash_data();
  } else {
    clear_has_app_crash_data();
  }
}

// -------------------------------------------------------------------

// ClientBeaconBatch_SessionInfo

// optional string id = 1;
inline bool ClientBeaconBatch_SessionInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch_SessionInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch_SessionInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch_SessionInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ClientBeaconBatch_SessionInfo::id() const {
  return *id_;
}
inline void ClientBeaconBatch_SessionInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ClientBeaconBatch_SessionInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ClientBeaconBatch_SessionInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_SessionInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ClientBeaconBatch_SessionInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_SessionInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 start_time = 2;
inline bool ClientBeaconBatch_SessionInfo::has_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch_SessionInfo::set_has_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch_SessionInfo::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch_SessionInfo::clear_start_time() {
  start_time_ = GOOGLE_LONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::int64 ClientBeaconBatch_SessionInfo::start_time() const {
  return start_time_;
}
inline void ClientBeaconBatch_SessionInfo::set_start_time(::google::protobuf::int64 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional int64 end_time = 3;
inline bool ClientBeaconBatch_SessionInfo::has_end_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientBeaconBatch_SessionInfo::set_has_end_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientBeaconBatch_SessionInfo::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientBeaconBatch_SessionInfo::clear_end_time() {
  end_time_ = GOOGLE_LONGLONG(0);
  clear_has_end_time();
}
inline ::google::protobuf::int64 ClientBeaconBatch_SessionInfo::end_time() const {
  return end_time_;
}
inline void ClientBeaconBatch_SessionInfo::set_end_time(::google::protobuf::int64 value) {
  set_has_end_time();
  end_time_ = value;
}

// optional int32 network_request_count_total = 4;
inline bool ClientBeaconBatch_SessionInfo::has_network_request_count_total() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientBeaconBatch_SessionInfo::set_has_network_request_count_total() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientBeaconBatch_SessionInfo::clear_has_network_request_count_total() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientBeaconBatch_SessionInfo::clear_network_request_count_total() {
  network_request_count_total_ = 0;
  clear_has_network_request_count_total();
}
inline ::google::protobuf::int32 ClientBeaconBatch_SessionInfo::network_request_count_total() const {
  return network_request_count_total_;
}
inline void ClientBeaconBatch_SessionInfo::set_network_request_count_total(::google::protobuf::int32 value) {
  set_has_network_request_count_total();
  network_request_count_total_ = value;
}

// optional int64 network_request_duration_total = 5;
inline bool ClientBeaconBatch_SessionInfo::has_network_request_duration_total() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientBeaconBatch_SessionInfo::set_has_network_request_duration_total() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientBeaconBatch_SessionInfo::clear_has_network_request_duration_total() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientBeaconBatch_SessionInfo::clear_network_request_duration_total() {
  network_request_duration_total_ = GOOGLE_LONGLONG(0);
  clear_has_network_request_duration_total();
}
inline ::google::protobuf::int64 ClientBeaconBatch_SessionInfo::network_request_duration_total() const {
  return network_request_duration_total_;
}
inline void ClientBeaconBatch_SessionInfo::set_network_request_duration_total(::google::protobuf::int64 value) {
  set_has_network_request_duration_total();
  network_request_duration_total_ = value;
}

// -------------------------------------------------------------------

// ClientBeaconBatch

// optional string boomerang_version = 1;
inline bool ClientBeaconBatch::has_boomerang_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch::set_has_boomerang_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch::clear_has_boomerang_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch::clear_boomerang_version() {
  if (boomerang_version_ != &::google::protobuf::internal::kEmptyString) {
    boomerang_version_->clear();
  }
  clear_has_boomerang_version();
}
inline const ::std::string& ClientBeaconBatch::boomerang_version() const {
  return *boomerang_version_;
}
inline void ClientBeaconBatch::set_boomerang_version(const ::std::string& value) {
  set_has_boomerang_version();
  if (boomerang_version_ == &::google::protobuf::internal::kEmptyString) {
    boomerang_version_ = new ::std::string;
  }
  boomerang_version_->assign(value);
}
inline void ClientBeaconBatch::set_boomerang_version(const char* value) {
  set_has_boomerang_version();
  if (boomerang_version_ == &::google::protobuf::internal::kEmptyString) {
    boomerang_version_ = new ::std::string;
  }
  boomerang_version_->assign(value);
}
inline void ClientBeaconBatch::set_boomerang_version(const char* value, size_t size) {
  set_has_boomerang_version();
  if (boomerang_version_ == &::google::protobuf::internal::kEmptyString) {
    boomerang_version_ = new ::std::string;
  }
  boomerang_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_boomerang_version() {
  set_has_boomerang_version();
  if (boomerang_version_ == &::google::protobuf::internal::kEmptyString) {
    boomerang_version_ = new ::std::string;
  }
  return boomerang_version_;
}
inline ::std::string* ClientBeaconBatch::release_boomerang_version() {
  clear_has_boomerang_version();
  if (boomerang_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = boomerang_version_;
    boomerang_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_boomerang_version(::std::string* boomerang_version) {
  if (boomerang_version_ != &::google::protobuf::internal::kEmptyString) {
    delete boomerang_version_;
  }
  if (boomerang_version) {
    set_has_boomerang_version();
    boomerang_version_ = boomerang_version;
  } else {
    clear_has_boomerang_version();
    boomerang_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string domain = 2;
inline bool ClientBeaconBatch::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& ClientBeaconBatch::domain() const {
  return *domain_;
}
inline void ClientBeaconBatch::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void ClientBeaconBatch::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void ClientBeaconBatch::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* ClientBeaconBatch::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string api_key = 3;
inline bool ClientBeaconBatch::has_api_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientBeaconBatch::set_has_api_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientBeaconBatch::clear_has_api_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientBeaconBatch::clear_api_key() {
  if (api_key_ != &::google::protobuf::internal::kEmptyString) {
    api_key_->clear();
  }
  clear_has_api_key();
}
inline const ::std::string& ClientBeaconBatch::api_key() const {
  return *api_key_;
}
inline void ClientBeaconBatch::set_api_key(const ::std::string& value) {
  set_has_api_key();
  if (api_key_ == &::google::protobuf::internal::kEmptyString) {
    api_key_ = new ::std::string;
  }
  api_key_->assign(value);
}
inline void ClientBeaconBatch::set_api_key(const char* value) {
  set_has_api_key();
  if (api_key_ == &::google::protobuf::internal::kEmptyString) {
    api_key_ = new ::std::string;
  }
  api_key_->assign(value);
}
inline void ClientBeaconBatch::set_api_key(const char* value, size_t size) {
  set_has_api_key();
  if (api_key_ == &::google::protobuf::internal::kEmptyString) {
    api_key_ = new ::std::string;
  }
  api_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_api_key() {
  set_has_api_key();
  if (api_key_ == &::google::protobuf::internal::kEmptyString) {
    api_key_ = new ::std::string;
  }
  return api_key_;
}
inline ::std::string* ClientBeaconBatch::release_api_key() {
  clear_has_api_key();
  if (api_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = api_key_;
    api_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_api_key(::std::string* api_key) {
  if (api_key_ != &::google::protobuf::internal::kEmptyString) {
    delete api_key_;
  }
  if (api_key) {
    set_has_api_key();
    api_key_ = api_key;
  } else {
    clear_has_api_key();
    api_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device = 4;
inline bool ClientBeaconBatch::has_device() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientBeaconBatch::set_has_device() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientBeaconBatch::clear_has_device() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientBeaconBatch::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& ClientBeaconBatch::device() const {
  return *device_;
}
inline void ClientBeaconBatch::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void ClientBeaconBatch::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void ClientBeaconBatch::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* ClientBeaconBatch::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string manufacturer = 5;
inline bool ClientBeaconBatch::has_manufacturer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientBeaconBatch::set_has_manufacturer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientBeaconBatch::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientBeaconBatch::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& ClientBeaconBatch::manufacturer() const {
  return *manufacturer_;
}
inline void ClientBeaconBatch::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void ClientBeaconBatch::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void ClientBeaconBatch::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* ClientBeaconBatch::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (manufacturer) {
    set_has_manufacturer();
    manufacturer_ = manufacturer;
  } else {
    clear_has_manufacturer();
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 6;
inline bool ClientBeaconBatch::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientBeaconBatch::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientBeaconBatch::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientBeaconBatch::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ClientBeaconBatch::type() const {
  return *type_;
}
inline void ClientBeaconBatch::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ClientBeaconBatch::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ClientBeaconBatch::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* ClientBeaconBatch::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string os = 7;
inline bool ClientBeaconBatch::has_os() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientBeaconBatch::set_has_os() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientBeaconBatch::clear_has_os() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientBeaconBatch::clear_os() {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& ClientBeaconBatch::os() const {
  return *os_;
}
inline void ClientBeaconBatch::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void ClientBeaconBatch::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void ClientBeaconBatch::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  return os_;
}
inline ::std::string* ClientBeaconBatch::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string isp = 8;
inline bool ClientBeaconBatch::has_isp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientBeaconBatch::set_has_isp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientBeaconBatch::clear_has_isp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientBeaconBatch::clear_isp() {
  if (isp_ != &::google::protobuf::internal::kEmptyString) {
    isp_->clear();
  }
  clear_has_isp();
}
inline const ::std::string& ClientBeaconBatch::isp() const {
  return *isp_;
}
inline void ClientBeaconBatch::set_isp(const ::std::string& value) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(value);
}
inline void ClientBeaconBatch::set_isp(const char* value) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(value);
}
inline void ClientBeaconBatch::set_isp(const char* value, size_t size) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_isp() {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  return isp_;
}
inline ::std::string* ClientBeaconBatch::release_isp() {
  clear_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = isp_;
    isp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_isp(::std::string* isp) {
  if (isp_ != &::google::protobuf::internal::kEmptyString) {
    delete isp_;
  }
  if (isp) {
    set_has_isp();
    isp_ = isp;
  } else {
    clear_has_isp();
    isp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string connection_type = 9;
inline bool ClientBeaconBatch::has_connection_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientBeaconBatch::set_has_connection_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientBeaconBatch::clear_has_connection_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientBeaconBatch::clear_connection_type() {
  if (connection_type_ != &::google::protobuf::internal::kEmptyString) {
    connection_type_->clear();
  }
  clear_has_connection_type();
}
inline const ::std::string& ClientBeaconBatch::connection_type() const {
  return *connection_type_;
}
inline void ClientBeaconBatch::set_connection_type(const ::std::string& value) {
  set_has_connection_type();
  if (connection_type_ == &::google::protobuf::internal::kEmptyString) {
    connection_type_ = new ::std::string;
  }
  connection_type_->assign(value);
}
inline void ClientBeaconBatch::set_connection_type(const char* value) {
  set_has_connection_type();
  if (connection_type_ == &::google::protobuf::internal::kEmptyString) {
    connection_type_ = new ::std::string;
  }
  connection_type_->assign(value);
}
inline void ClientBeaconBatch::set_connection_type(const char* value, size_t size) {
  set_has_connection_type();
  if (connection_type_ == &::google::protobuf::internal::kEmptyString) {
    connection_type_ = new ::std::string;
  }
  connection_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_connection_type() {
  set_has_connection_type();
  if (connection_type_ == &::google::protobuf::internal::kEmptyString) {
    connection_type_ = new ::std::string;
  }
  return connection_type_;
}
inline ::std::string* ClientBeaconBatch::release_connection_type() {
  clear_has_connection_type();
  if (connection_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connection_type_;
    connection_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_connection_type(::std::string* connection_type) {
  if (connection_type_ != &::google::protobuf::internal::kEmptyString) {
    delete connection_type_;
  }
  if (connection_type) {
    set_has_connection_type();
    connection_type_ = connection_type;
  } else {
    clear_has_connection_type();
    connection_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string site_version = 10;
inline bool ClientBeaconBatch::has_site_version() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientBeaconBatch::set_has_site_version() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientBeaconBatch::clear_has_site_version() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientBeaconBatch::clear_site_version() {
  if (site_version_ != &::google::protobuf::internal::kEmptyString) {
    site_version_->clear();
  }
  clear_has_site_version();
}
inline const ::std::string& ClientBeaconBatch::site_version() const {
  return *site_version_;
}
inline void ClientBeaconBatch::set_site_version(const ::std::string& value) {
  set_has_site_version();
  if (site_version_ == &::google::protobuf::internal::kEmptyString) {
    site_version_ = new ::std::string;
  }
  site_version_->assign(value);
}
inline void ClientBeaconBatch::set_site_version(const char* value) {
  set_has_site_version();
  if (site_version_ == &::google::protobuf::internal::kEmptyString) {
    site_version_ = new ::std::string;
  }
  site_version_->assign(value);
}
inline void ClientBeaconBatch::set_site_version(const char* value, size_t size) {
  set_has_site_version();
  if (site_version_ == &::google::protobuf::internal::kEmptyString) {
    site_version_ = new ::std::string;
  }
  site_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_site_version() {
  set_has_site_version();
  if (site_version_ == &::google::protobuf::internal::kEmptyString) {
    site_version_ = new ::std::string;
  }
  return site_version_;
}
inline ::std::string* ClientBeaconBatch::release_site_version() {
  clear_has_site_version();
  if (site_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = site_version_;
    site_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_site_version(::std::string* site_version) {
  if (site_version_ != &::google::protobuf::internal::kEmptyString) {
    delete site_version_;
  }
  if (site_version) {
    set_has_site_version();
    site_version_ = site_version;
  } else {
    clear_has_site_version();
    site_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float latitude = 11;
inline bool ClientBeaconBatch::has_latitude() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientBeaconBatch::set_has_latitude() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientBeaconBatch::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientBeaconBatch::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float ClientBeaconBatch::latitude() const {
  return latitude_;
}
inline void ClientBeaconBatch::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
}

// optional float longitude = 12;
inline bool ClientBeaconBatch::has_longitude() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ClientBeaconBatch::set_has_longitude() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ClientBeaconBatch::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ClientBeaconBatch::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float ClientBeaconBatch::longitude() const {
  return longitude_;
}
inline void ClientBeaconBatch::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
}

// optional .client_beacon_batch.ClientBeaconBatch.SessionInfo session = 13;
inline bool ClientBeaconBatch::has_session() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ClientBeaconBatch::set_has_session() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ClientBeaconBatch::clear_has_session() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ClientBeaconBatch::clear_session() {
  if (session_ != NULL) session_->::client_beacon_batch::ClientBeaconBatch_SessionInfo::Clear();
  clear_has_session();
}
inline const ::client_beacon_batch::ClientBeaconBatch_SessionInfo& ClientBeaconBatch::session() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return session_ != NULL ? *session_ : *default_instance().session_;
#else
  return session_ != NULL ? *session_ : *default_instance_->session_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_SessionInfo* ClientBeaconBatch::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::client_beacon_batch::ClientBeaconBatch_SessionInfo;
  return session_;
}
inline ::client_beacon_batch::ClientBeaconBatch_SessionInfo* ClientBeaconBatch::release_session() {
  clear_has_session();
  ::client_beacon_batch::ClientBeaconBatch_SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}
inline void ClientBeaconBatch::set_allocated_session(::client_beacon_batch::ClientBeaconBatch_SessionInfo* session) {
  delete session_;
  session_ = session;
  if (session) {
    set_has_session();
  } else {
    clear_has_session();
  }
}

// repeated .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord records = 14;
inline int ClientBeaconBatch::records_size() const {
  return records_.size();
}
inline void ClientBeaconBatch::clear_records() {
  records_.Clear();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord& ClientBeaconBatch::records(int index) const {
  return records_.Get(index);
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord* ClientBeaconBatch::mutable_records(int index) {
  return records_.Mutable(index);
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord* ClientBeaconBatch::add_records() {
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord >&
ClientBeaconBatch::records() const {
  return records_;
}
inline ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord >*
ClientBeaconBatch::mutable_records() {
  return &records_;
}

// repeated .client_beacon_batch.ClientBeaconBatch.ClientBeaconRecord beacon_records = 15;
inline int ClientBeaconBatch::beacon_records_size() const {
  return beacon_records_.size();
}
inline void ClientBeaconBatch::clear_beacon_records() {
  beacon_records_.Clear();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord& ClientBeaconBatch::beacon_records(int index) const {
  return beacon_records_.Get(index);
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord* ClientBeaconBatch::mutable_beacon_records(int index) {
  return beacon_records_.Mutable(index);
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord* ClientBeaconBatch::add_beacon_records() {
  return beacon_records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord >&
ClientBeaconBatch::beacon_records() const {
  return beacon_records_;
}
inline ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconRecord >*
ClientBeaconBatch::mutable_beacon_records() {
  return &beacon_records_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client_beacon_batch

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ClientBeaconBatch_2eproto__INCLUDED
