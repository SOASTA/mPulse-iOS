// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ClientBeaconBatch.proto

#ifndef PROTOBUF_ClientBeaconBatch_2eproto__INCLUDED
#define PROTOBUF_ClientBeaconBatch_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace client_beacon_batch {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

class ClientBeaconBatch;
class ClientBeaconBatch_ClientBeaconBatchRecord;
class ClientBeaconBatch_ClientBeaconBatchRecord_TimerData;
class ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers;
class ClientBeaconBatch_SessionInfo;

// ===================================================================

class ClientBeaconBatch_ClientBeaconBatchRecord_TimerData : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_ClientBeaconBatchRecord_TimerData();
  virtual ~ClientBeaconBatch_ClientBeaconBatchRecord_TimerData();

  ClientBeaconBatch_ClientBeaconBatchRecord_TimerData(const ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& from);

  inline ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& operator=(const ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& from);
  void MergeFrom(const ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline ::google::protobuf::int32 total() const;
  inline void set_total(::google::protobuf::int32 value);

  // optional int32 min = 2;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 2;
  inline ::google::protobuf::int32 min() const;
  inline void set_min(::google::protobuf::int32 value);

  // optional int32 max = 3;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 3;
  inline ::google::protobuf::int32 max() const;
  inline void set_max(::google::protobuf::int32 value);

  // optional int64 sum = 4;
  inline bool has_sum() const;
  inline void clear_sum();
  static const int kSumFieldNumber = 4;
  inline ::google::protobuf::int64 sum() const;
  inline void set_sum(::google::protobuf::int64 value);

  // optional int64 sum_sq = 5;
  inline bool has_sum_sq() const;
  inline void clear_sum_sq();
  static const int kSumSqFieldNumber = 5;
  inline ::google::protobuf::int64 sum_sq() const;
  inline void set_sum_sq(::google::protobuf::int64 value);

  // optional bytes histogram = 6;
  inline bool has_histogram() const;
  inline void clear_histogram();
  static const int kHistogramFieldNumber = 6;
  inline const ::std::string& histogram() const;
  inline void set_histogram(const ::std::string& value);
  inline void set_histogram(const char* value);
  inline void set_histogram(const void* value, size_t size);
  inline ::std::string* mutable_histogram();
  inline ::std::string* release_histogram();
  inline void set_allocated_histogram(::std::string* histogram);

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_min();
  inline void clear_has_min();
  inline void set_has_max();
  inline void clear_has_max();
  inline void set_has_sum();
  inline void clear_has_sum();
  inline void set_has_sum_sq();
  inline void clear_has_sum_sq();
  inline void set_has_histogram();
  inline void clear_has_histogram();

  ::google::protobuf::int32 total_;
  ::google::protobuf::int32 min_;
  ::google::protobuf::int64 sum_;
  ::google::protobuf::int64 sum_sq_;
  ::std::string* histogram_;
  ::google::protobuf::int32 max_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers();
  virtual ~ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers();

  ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers(const ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& from);

  inline ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& operator=(const ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& from);
  void MergeFrom(const ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData request_duration_timer = 1;
  inline bool has_request_duration_timer() const;
  inline void clear_request_duration_timer();
  static const int kRequestDurationTimerFieldNumber = 1;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& request_duration_timer() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* mutable_request_duration_timer();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* release_request_duration_timer();
  inline void set_allocated_request_duration_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* request_duration_timer);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData dns_timer = 2;
  inline bool has_dns_timer() const;
  inline void clear_dns_timer();
  static const int kDnsTimerFieldNumber = 2;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& dns_timer() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* mutable_dns_timer();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* release_dns_timer();
  inline void set_allocated_dns_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* dns_timer);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData tcp_timer = 3;
  inline bool has_tcp_timer() const;
  inline void clear_tcp_timer();
  static const int kTcpTimerFieldNumber = 3;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& tcp_timer() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* mutable_tcp_timer();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* release_tcp_timer();
  inline void set_allocated_tcp_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* tcp_timer);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData ssl_timer = 4;
  inline bool has_ssl_timer() const;
  inline void clear_ssl_timer();
  static const int kSslTimerFieldNumber = 4;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ssl_timer() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* mutable_ssl_timer();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* release_ssl_timer();
  inline void set_allocated_ssl_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ssl_timer);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData time_to_first_byte_timer = 5;
  inline bool has_time_to_first_byte_timer() const;
  inline void clear_time_to_first_byte_timer();
  static const int kTimeToFirstByteTimerFieldNumber = 5;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& time_to_first_byte_timer() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* mutable_time_to_first_byte_timer();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* release_time_to_first_byte_timer();
  inline void set_allocated_time_to_first_byte_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* time_to_first_byte_timer);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData time_to_last_byte_timer = 6;
  inline bool has_time_to_last_byte_timer() const;
  inline void clear_time_to_last_byte_timer();
  static const int kTimeToLastByteTimerFieldNumber = 6;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& time_to_last_byte_timer() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* mutable_time_to_last_byte_timer();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* release_time_to_last_byte_timer();
  inline void set_allocated_time_to_last_byte_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* time_to_last_byte_timer);

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.NetworkTimers)
 private:
  inline void set_has_request_duration_timer();
  inline void clear_has_request_duration_timer();
  inline void set_has_dns_timer();
  inline void clear_has_dns_timer();
  inline void set_has_tcp_timer();
  inline void clear_has_tcp_timer();
  inline void set_has_ssl_timer();
  inline void clear_has_ssl_timer();
  inline void set_has_time_to_first_byte_timer();
  inline void clear_has_time_to_first_byte_timer();
  inline void set_has_time_to_last_byte_timer();
  inline void clear_has_time_to_last_byte_timer();

  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* request_duration_timer_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* dns_timer_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* tcp_timer_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ssl_timer_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* time_to_first_byte_timer_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* time_to_last_byte_timer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch_ClientBeaconBatchRecord : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_ClientBeaconBatchRecord();
  virtual ~ClientBeaconBatch_ClientBeaconBatchRecord();

  ClientBeaconBatch_ClientBeaconBatchRecord(const ClientBeaconBatch_ClientBeaconBatchRecord& from);

  inline ClientBeaconBatch_ClientBeaconBatchRecord& operator=(const ClientBeaconBatch_ClientBeaconBatchRecord& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_ClientBeaconBatchRecord& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_ClientBeaconBatchRecord* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_ClientBeaconBatchRecord* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_ClientBeaconBatchRecord* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_ClientBeaconBatchRecord& from);
  void MergeFrom(const ClientBeaconBatch_ClientBeaconBatchRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClientBeaconBatch_ClientBeaconBatchRecord_TimerData TimerData;
  typedef ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers NetworkTimers;

  // accessors -------------------------------------------------------

  // optional string page_group = 1;
  inline bool has_page_group() const;
  inline void clear_page_group();
  static const int kPageGroupFieldNumber = 1;
  inline const ::std::string& page_group() const;
  inline void set_page_group(const ::std::string& value);
  inline void set_page_group(const char* value);
  inline void set_page_group(const char* value, size_t size);
  inline ::std::string* mutable_page_group();
  inline ::std::string* release_page_group();
  inline void set_allocated_page_group(::std::string* page_group);

  // optional string ab_test = 2;
  inline bool has_ab_test() const;
  inline void clear_ab_test();
  static const int kAbTestFieldNumber = 2;
  inline const ::std::string& ab_test() const;
  inline void set_ab_test(const ::std::string& value);
  inline void set_ab_test(const char* value);
  inline void set_ab_test(const char* value, size_t size);
  inline ::std::string* mutable_ab_test();
  inline ::std::string* release_ab_test();
  inline void set_allocated_ab_test(::std::string* ab_test);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional int32 network_error_code = 4;
  inline bool has_network_error_code() const;
  inline void clear_network_error_code();
  static const int kNetworkErrorCodeFieldNumber = 4;
  inline ::google::protobuf::int32 network_error_code() const;
  inline void set_network_error_code(::google::protobuf::int32 value);

  // optional int64 timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.NetworkTimers network_timers = 6;
  inline bool has_network_timers() const;
  inline void clear_network_timers();
  static const int kNetworkTimersFieldNumber = 6;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& network_timers() const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* mutable_network_timers();
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* release_network_timers();
  inline void set_allocated_network_timers(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* network_timers);

  // repeated .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData custom_timers = 7;
  inline int custom_timers_size() const;
  inline void clear_custom_timers();
  static const int kCustomTimersFieldNumber = 7;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& custom_timers(int index) const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* mutable_custom_timers(int index);
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* add_custom_timers();
  inline const ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData >&
      custom_timers() const;
  inline ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData >*
      mutable_custom_timers();

  // repeated int64 custom_metrics = 8;
  inline int custom_metrics_size() const;
  inline void clear_custom_metrics();
  static const int kCustomMetricsFieldNumber = 8;
  inline ::google::protobuf::int64 custom_metrics(int index) const;
  inline void set_custom_metrics(int index, ::google::protobuf::int64 value);
  inline void add_custom_metrics(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      custom_metrics() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_custom_metrics();

  // optional int32 beacon_total = 9;
  inline bool has_beacon_total() const;
  inline void clear_beacon_total();
  static const int kBeaconTotalFieldNumber = 9;
  inline ::google::protobuf::int32 beacon_total() const;
  inline void set_beacon_total(::google::protobuf::int32 value);

  // optional int32 crashes_total = 10;
  inline bool has_crashes_total() const;
  inline void clear_crashes_total();
  static const int kCrashesTotalFieldNumber = 10;
  inline ::google::protobuf::int32 crashes_total() const;
  inline void set_crashes_total(::google::protobuf::int32 value);

  // optional int32 installs_total = 11;
  inline bool has_installs_total() const;
  inline void clear_installs_total();
  static const int kInstallsTotalFieldNumber = 11;
  inline ::google::protobuf::int32 installs_total() const;
  inline void set_installs_total(::google::protobuf::int32 value);

  // repeated string custom_dimensions = 12;
  inline int custom_dimensions_size() const;
  inline void clear_custom_dimensions();
  static const int kCustomDimensionsFieldNumber = 12;
  inline const ::std::string& custom_dimensions(int index) const;
  inline ::std::string* mutable_custom_dimensions(int index);
  inline void set_custom_dimensions(int index, const ::std::string& value);
  inline void set_custom_dimensions(int index, const char* value);
  inline void set_custom_dimensions(int index, const char* value, size_t size);
  inline ::std::string* add_custom_dimensions();
  inline void add_custom_dimensions(const ::std::string& value);
  inline void add_custom_dimensions(const char* value);
  inline void add_custom_dimensions(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& custom_dimensions() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_custom_dimensions();

  // optional string beacon_type = 13;
  inline bool has_beacon_type() const;
  inline void clear_beacon_type();
  static const int kBeaconTypeFieldNumber = 13;
  inline const ::std::string& beacon_type() const;
  inline void set_beacon_type(const ::std::string& value);
  inline void set_beacon_type(const char* value);
  inline void set_beacon_type(const char* value, size_t size);
  inline ::std::string* mutable_beacon_type();
  inline ::std::string* release_beacon_type();
  inline void set_allocated_beacon_type(::std::string* beacon_type);

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord)
 private:
  inline void set_has_page_group();
  inline void clear_has_page_group();
  inline void set_has_ab_test();
  inline void clear_has_ab_test();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_network_error_code();
  inline void clear_has_network_error_code();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_network_timers();
  inline void clear_has_network_timers();
  inline void set_has_beacon_total();
  inline void clear_has_beacon_total();
  inline void set_has_crashes_total();
  inline void clear_has_crashes_total();
  inline void set_has_installs_total();
  inline void clear_has_installs_total();
  inline void set_has_beacon_type();
  inline void clear_has_beacon_type();

  ::std::string* page_group_;
  ::std::string* ab_test_;
  ::std::string* url_;
  ::google::protobuf::int64 timestamp_;
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* network_timers_;
  ::google::protobuf::int32 network_error_code_;
  ::google::protobuf::int32 beacon_total_;
  ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData > custom_timers_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > custom_metrics_;
  ::google::protobuf::int32 crashes_total_;
  ::google::protobuf::int32 installs_total_;
  ::google::protobuf::RepeatedPtrField< ::std::string> custom_dimensions_;
  ::std::string* beacon_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_ClientBeaconBatchRecord* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch_SessionInfo : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch_SessionInfo();
  virtual ~ClientBeaconBatch_SessionInfo();

  ClientBeaconBatch_SessionInfo(const ClientBeaconBatch_SessionInfo& from);

  inline ClientBeaconBatch_SessionInfo& operator=(const ClientBeaconBatch_SessionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch_SessionInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch_SessionInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch_SessionInfo* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch_SessionInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch_SessionInfo& from);
  void MergeFrom(const ClientBeaconBatch_SessionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int64 start_time = 2;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  inline ::google::protobuf::int64 start_time() const;
  inline void set_start_time(::google::protobuf::int64 value);

  // optional int64 end_time = 3;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 3;
  inline ::google::protobuf::int64 end_time() const;
  inline void set_end_time(::google::protobuf::int64 value);

  // optional int32 network_request_count_total = 4;
  inline bool has_network_request_count_total() const;
  inline void clear_network_request_count_total();
  static const int kNetworkRequestCountTotalFieldNumber = 4;
  inline ::google::protobuf::int32 network_request_count_total() const;
  inline void set_network_request_count_total(::google::protobuf::int32 value);

  // optional int64 network_request_duration_total = 5;
  inline bool has_network_request_duration_total() const;
  inline void clear_network_request_duration_total();
  static const int kNetworkRequestDurationTotalFieldNumber = 5;
  inline ::google::protobuf::int64 network_request_duration_total() const;
  inline void set_network_request_duration_total(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch.SessionInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_network_request_count_total();
  inline void clear_has_network_request_count_total();
  inline void set_has_network_request_duration_total();
  inline void clear_has_network_request_duration_total();

  ::std::string* id_;
  ::google::protobuf::int64 start_time_;
  ::google::protobuf::int64 end_time_;
  ::google::protobuf::int64 network_request_duration_total_;
  ::google::protobuf::int32 network_request_count_total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch_SessionInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientBeaconBatch : public ::google::protobuf::MessageLite {
 public:
  ClientBeaconBatch();
  virtual ~ClientBeaconBatch();

  ClientBeaconBatch(const ClientBeaconBatch& from);

  inline ClientBeaconBatch& operator=(const ClientBeaconBatch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientBeaconBatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientBeaconBatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientBeaconBatch* other);

  // implements Message ----------------------------------------------

  ClientBeaconBatch* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientBeaconBatch& from);
  void MergeFrom(const ClientBeaconBatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClientBeaconBatch_ClientBeaconBatchRecord ClientBeaconBatchRecord;
  typedef ClientBeaconBatch_SessionInfo SessionInfo;

  // accessors -------------------------------------------------------

  // optional string boomerang_version = 1;
  inline bool has_boomerang_version() const;
  inline void clear_boomerang_version();
  static const int kBoomerangVersionFieldNumber = 1;
  inline const ::std::string& boomerang_version() const;
  inline void set_boomerang_version(const ::std::string& value);
  inline void set_boomerang_version(const char* value);
  inline void set_boomerang_version(const char* value, size_t size);
  inline ::std::string* mutable_boomerang_version();
  inline ::std::string* release_boomerang_version();
  inline void set_allocated_boomerang_version(::std::string* boomerang_version);

  // optional string domain = 2;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 2;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional string api_key = 3;
  inline bool has_api_key() const;
  inline void clear_api_key();
  static const int kApiKeyFieldNumber = 3;
  inline const ::std::string& api_key() const;
  inline void set_api_key(const ::std::string& value);
  inline void set_api_key(const char* value);
  inline void set_api_key(const char* value, size_t size);
  inline ::std::string* mutable_api_key();
  inline ::std::string* release_api_key();
  inline void set_allocated_api_key(::std::string* api_key);

  // optional string device = 4;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 4;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional string manufacturer = 5;
  inline bool has_manufacturer() const;
  inline void clear_manufacturer();
  static const int kManufacturerFieldNumber = 5;
  inline const ::std::string& manufacturer() const;
  inline void set_manufacturer(const ::std::string& value);
  inline void set_manufacturer(const char* value);
  inline void set_manufacturer(const char* value, size_t size);
  inline ::std::string* mutable_manufacturer();
  inline ::std::string* release_manufacturer();
  inline void set_allocated_manufacturer(::std::string* manufacturer);

  // optional string type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string os = 7;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 7;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string isp = 8;
  inline bool has_isp() const;
  inline void clear_isp();
  static const int kIspFieldNumber = 8;
  inline const ::std::string& isp() const;
  inline void set_isp(const ::std::string& value);
  inline void set_isp(const char* value);
  inline void set_isp(const char* value, size_t size);
  inline ::std::string* mutable_isp();
  inline ::std::string* release_isp();
  inline void set_allocated_isp(::std::string* isp);

  // optional string connection_type = 9;
  inline bool has_connection_type() const;
  inline void clear_connection_type();
  static const int kConnectionTypeFieldNumber = 9;
  inline const ::std::string& connection_type() const;
  inline void set_connection_type(const ::std::string& value);
  inline void set_connection_type(const char* value);
  inline void set_connection_type(const char* value, size_t size);
  inline ::std::string* mutable_connection_type();
  inline ::std::string* release_connection_type();
  inline void set_allocated_connection_type(::std::string* connection_type);

  // optional string site_version = 10;
  inline bool has_site_version() const;
  inline void clear_site_version();
  static const int kSiteVersionFieldNumber = 10;
  inline const ::std::string& site_version() const;
  inline void set_site_version(const ::std::string& value);
  inline void set_site_version(const char* value);
  inline void set_site_version(const char* value, size_t size);
  inline ::std::string* mutable_site_version();
  inline ::std::string* release_site_version();
  inline void set_allocated_site_version(::std::string* site_version);

  // optional float latitude = 11;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 11;
  inline float latitude() const;
  inline void set_latitude(float value);

  // optional float longitude = 12;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 12;
  inline float longitude() const;
  inline void set_longitude(float value);

  // optional .client_beacon_batch.ClientBeaconBatch.SessionInfo session = 13;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 13;
  inline const ::client_beacon_batch::ClientBeaconBatch_SessionInfo& session() const;
  inline ::client_beacon_batch::ClientBeaconBatch_SessionInfo* mutable_session();
  inline ::client_beacon_batch::ClientBeaconBatch_SessionInfo* release_session();
  inline void set_allocated_session(::client_beacon_batch::ClientBeaconBatch_SessionInfo* session);

  // repeated .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord records = 14;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 14;
  inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord& records(int index) const;
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord* mutable_records(int index);
  inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord* add_records();
  inline const ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord >&
      records() const;
  inline ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord >*
      mutable_records();

  // @@protoc_insertion_point(class_scope:client_beacon_batch.ClientBeaconBatch)
 private:
  inline void set_has_boomerang_version();
  inline void clear_has_boomerang_version();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_api_key();
  inline void clear_has_api_key();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_manufacturer();
  inline void clear_has_manufacturer();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_isp();
  inline void clear_has_isp();
  inline void set_has_connection_type();
  inline void clear_has_connection_type();
  inline void set_has_site_version();
  inline void clear_has_site_version();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_session();
  inline void clear_has_session();

  ::std::string* boomerang_version_;
  ::std::string* domain_;
  ::std::string* api_key_;
  ::std::string* device_;
  ::std::string* manufacturer_;
  ::std::string* type_;
  ::std::string* os_;
  ::std::string* isp_;
  ::std::string* connection_type_;
  ::std::string* site_version_;
  float latitude_;
  float longitude_;
  ::client_beacon_batch::ClientBeaconBatch_SessionInfo* session_;
  ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord > records_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientBeaconBatch_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientBeaconBatch_2eproto();
  friend void protobuf_ShutdownFile_ClientBeaconBatch_2eproto();

  void InitAsDefaultInstance();
  static ClientBeaconBatch* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientBeaconBatch_ClientBeaconBatchRecord_TimerData

// optional int32 total = 1;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::total() const {
  return total_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
}

// optional int32 min = 2;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::has_min() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_has_min() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_has_min() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_min() {
  min_ = 0;
  clear_has_min();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::min() const {
  return min_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_min(::google::protobuf::int32 value) {
  set_has_min();
  min_ = value;
}

// optional int32 max = 3;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::has_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_has_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_has_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::max() const {
  return max_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_max(::google::protobuf::int32 value) {
  set_has_max();
  max_ = value;
}

// optional int64 sum = 4;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::has_sum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_has_sum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_has_sum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_sum() {
  sum_ = GOOGLE_LONGLONG(0);
  clear_has_sum();
}
inline ::google::protobuf::int64 ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::sum() const {
  return sum_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_sum(::google::protobuf::int64 value) {
  set_has_sum();
  sum_ = value;
}

// optional int64 sum_sq = 5;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::has_sum_sq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_has_sum_sq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_has_sum_sq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_sum_sq() {
  sum_sq_ = GOOGLE_LONGLONG(0);
  clear_has_sum_sq();
}
inline ::google::protobuf::int64 ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::sum_sq() const {
  return sum_sq_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_sum_sq(::google::protobuf::int64 value) {
  set_has_sum_sq();
  sum_sq_ = value;
}

// optional bytes histogram = 6;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::has_histogram() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_has_histogram() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_has_histogram() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::clear_histogram() {
  if (histogram_ != &::google::protobuf::internal::kEmptyString) {
    histogram_->clear();
  }
  clear_has_histogram();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::histogram() const {
  return *histogram_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_histogram(const ::std::string& value) {
  set_has_histogram();
  if (histogram_ == &::google::protobuf::internal::kEmptyString) {
    histogram_ = new ::std::string;
  }
  histogram_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_histogram(const char* value) {
  set_has_histogram();
  if (histogram_ == &::google::protobuf::internal::kEmptyString) {
    histogram_ = new ::std::string;
  }
  histogram_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_histogram(const void* value, size_t size) {
  set_has_histogram();
  if (histogram_ == &::google::protobuf::internal::kEmptyString) {
    histogram_ = new ::std::string;
  }
  histogram_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::mutable_histogram() {
  set_has_histogram();
  if (histogram_ == &::google::protobuf::internal::kEmptyString) {
    histogram_ = new ::std::string;
  }
  return histogram_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::release_histogram() {
  clear_has_histogram();
  if (histogram_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = histogram_;
    histogram_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::set_allocated_histogram(::std::string* histogram) {
  if (histogram_ != &::google::protobuf::internal::kEmptyString) {
    delete histogram_;
  }
  if (histogram) {
    set_has_histogram();
    histogram_ = histogram;
  } else {
    clear_has_histogram();
    histogram_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData request_duration_timer = 1;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::has_request_duration_timer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_has_request_duration_timer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_has_request_duration_timer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_request_duration_timer() {
  if (request_duration_timer_ != NULL) request_duration_timer_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::Clear();
  clear_has_request_duration_timer();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::request_duration_timer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return request_duration_timer_ != NULL ? *request_duration_timer_ : *default_instance().request_duration_timer_;
#else
  return request_duration_timer_ != NULL ? *request_duration_timer_ : *default_instance_->request_duration_timer_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::mutable_request_duration_timer() {
  set_has_request_duration_timer();
  if (request_duration_timer_ == NULL) request_duration_timer_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData;
  return request_duration_timer_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::release_request_duration_timer() {
  clear_has_request_duration_timer();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* temp = request_duration_timer_;
  request_duration_timer_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_allocated_request_duration_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* request_duration_timer) {
  delete request_duration_timer_;
  request_duration_timer_ = request_duration_timer;
  if (request_duration_timer) {
    set_has_request_duration_timer();
  } else {
    clear_has_request_duration_timer();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData dns_timer = 2;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::has_dns_timer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_has_dns_timer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_has_dns_timer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_dns_timer() {
  if (dns_timer_ != NULL) dns_timer_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::Clear();
  clear_has_dns_timer();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::dns_timer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dns_timer_ != NULL ? *dns_timer_ : *default_instance().dns_timer_;
#else
  return dns_timer_ != NULL ? *dns_timer_ : *default_instance_->dns_timer_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::mutable_dns_timer() {
  set_has_dns_timer();
  if (dns_timer_ == NULL) dns_timer_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData;
  return dns_timer_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::release_dns_timer() {
  clear_has_dns_timer();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* temp = dns_timer_;
  dns_timer_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_allocated_dns_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* dns_timer) {
  delete dns_timer_;
  dns_timer_ = dns_timer;
  if (dns_timer) {
    set_has_dns_timer();
  } else {
    clear_has_dns_timer();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData tcp_timer = 3;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::has_tcp_timer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_has_tcp_timer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_has_tcp_timer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_tcp_timer() {
  if (tcp_timer_ != NULL) tcp_timer_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::Clear();
  clear_has_tcp_timer();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::tcp_timer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tcp_timer_ != NULL ? *tcp_timer_ : *default_instance().tcp_timer_;
#else
  return tcp_timer_ != NULL ? *tcp_timer_ : *default_instance_->tcp_timer_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::mutable_tcp_timer() {
  set_has_tcp_timer();
  if (tcp_timer_ == NULL) tcp_timer_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData;
  return tcp_timer_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::release_tcp_timer() {
  clear_has_tcp_timer();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* temp = tcp_timer_;
  tcp_timer_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_allocated_tcp_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* tcp_timer) {
  delete tcp_timer_;
  tcp_timer_ = tcp_timer;
  if (tcp_timer) {
    set_has_tcp_timer();
  } else {
    clear_has_tcp_timer();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData ssl_timer = 4;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::has_ssl_timer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_has_ssl_timer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_has_ssl_timer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_ssl_timer() {
  if (ssl_timer_ != NULL) ssl_timer_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::Clear();
  clear_has_ssl_timer();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::ssl_timer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ssl_timer_ != NULL ? *ssl_timer_ : *default_instance().ssl_timer_;
#else
  return ssl_timer_ != NULL ? *ssl_timer_ : *default_instance_->ssl_timer_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::mutable_ssl_timer() {
  set_has_ssl_timer();
  if (ssl_timer_ == NULL) ssl_timer_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData;
  return ssl_timer_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::release_ssl_timer() {
  clear_has_ssl_timer();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* temp = ssl_timer_;
  ssl_timer_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_allocated_ssl_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ssl_timer) {
  delete ssl_timer_;
  ssl_timer_ = ssl_timer;
  if (ssl_timer) {
    set_has_ssl_timer();
  } else {
    clear_has_ssl_timer();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData time_to_first_byte_timer = 5;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::has_time_to_first_byte_timer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_has_time_to_first_byte_timer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_has_time_to_first_byte_timer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_time_to_first_byte_timer() {
  if (time_to_first_byte_timer_ != NULL) time_to_first_byte_timer_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::Clear();
  clear_has_time_to_first_byte_timer();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::time_to_first_byte_timer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return time_to_first_byte_timer_ != NULL ? *time_to_first_byte_timer_ : *default_instance().time_to_first_byte_timer_;
#else
  return time_to_first_byte_timer_ != NULL ? *time_to_first_byte_timer_ : *default_instance_->time_to_first_byte_timer_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::mutable_time_to_first_byte_timer() {
  set_has_time_to_first_byte_timer();
  if (time_to_first_byte_timer_ == NULL) time_to_first_byte_timer_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData;
  return time_to_first_byte_timer_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::release_time_to_first_byte_timer() {
  clear_has_time_to_first_byte_timer();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* temp = time_to_first_byte_timer_;
  time_to_first_byte_timer_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_allocated_time_to_first_byte_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* time_to_first_byte_timer) {
  delete time_to_first_byte_timer_;
  time_to_first_byte_timer_ = time_to_first_byte_timer;
  if (time_to_first_byte_timer) {
    set_has_time_to_first_byte_timer();
  } else {
    clear_has_time_to_first_byte_timer();
  }
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData time_to_last_byte_timer = 6;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::has_time_to_last_byte_timer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_has_time_to_last_byte_timer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_has_time_to_last_byte_timer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::clear_time_to_last_byte_timer() {
  if (time_to_last_byte_timer_ != NULL) time_to_last_byte_timer_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData::Clear();
  clear_has_time_to_last_byte_timer();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::time_to_last_byte_timer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return time_to_last_byte_timer_ != NULL ? *time_to_last_byte_timer_ : *default_instance().time_to_last_byte_timer_;
#else
  return time_to_last_byte_timer_ != NULL ? *time_to_last_byte_timer_ : *default_instance_->time_to_last_byte_timer_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::mutable_time_to_last_byte_timer() {
  set_has_time_to_last_byte_timer();
  if (time_to_last_byte_timer_ == NULL) time_to_last_byte_timer_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData;
  return time_to_last_byte_timer_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::release_time_to_last_byte_timer() {
  clear_has_time_to_last_byte_timer();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* temp = time_to_last_byte_timer_;
  time_to_last_byte_timer_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::set_allocated_time_to_last_byte_timer(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* time_to_last_byte_timer) {
  delete time_to_last_byte_timer_;
  time_to_last_byte_timer_ = time_to_last_byte_timer;
  if (time_to_last_byte_timer) {
    set_has_time_to_last_byte_timer();
  } else {
    clear_has_time_to_last_byte_timer();
  }
}

// -------------------------------------------------------------------

// ClientBeaconBatch_ClientBeaconBatchRecord

// optional string page_group = 1;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_page_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_page_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_page_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_page_group() {
  if (page_group_ != &::google::protobuf::internal::kEmptyString) {
    page_group_->clear();
  }
  clear_has_page_group();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconBatchRecord::page_group() const {
  return *page_group_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_page_group(const ::std::string& value) {
  set_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    page_group_ = new ::std::string;
  }
  page_group_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_page_group(const char* value) {
  set_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    page_group_ = new ::std::string;
  }
  page_group_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_page_group(const char* value, size_t size) {
  set_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    page_group_ = new ::std::string;
  }
  page_group_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::mutable_page_group() {
  set_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    page_group_ = new ::std::string;
  }
  return page_group_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::release_page_group() {
  clear_has_page_group();
  if (page_group_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = page_group_;
    page_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_allocated_page_group(::std::string* page_group) {
  if (page_group_ != &::google::protobuf::internal::kEmptyString) {
    delete page_group_;
  }
  if (page_group) {
    set_has_page_group();
    page_group_ = page_group;
  } else {
    clear_has_page_group();
    page_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ab_test = 2;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_ab_test() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_ab_test() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_ab_test() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_ab_test() {
  if (ab_test_ != &::google::protobuf::internal::kEmptyString) {
    ab_test_->clear();
  }
  clear_has_ab_test();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconBatchRecord::ab_test() const {
  return *ab_test_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_ab_test(const ::std::string& value) {
  set_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    ab_test_ = new ::std::string;
  }
  ab_test_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_ab_test(const char* value) {
  set_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    ab_test_ = new ::std::string;
  }
  ab_test_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_ab_test(const char* value, size_t size) {
  set_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    ab_test_ = new ::std::string;
  }
  ab_test_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::mutable_ab_test() {
  set_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    ab_test_ = new ::std::string;
  }
  return ab_test_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::release_ab_test() {
  clear_has_ab_test();
  if (ab_test_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ab_test_;
    ab_test_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_allocated_ab_test(::std::string* ab_test) {
  if (ab_test_ != &::google::protobuf::internal::kEmptyString) {
    delete ab_test_;
  }
  if (ab_test) {
    set_has_ab_test();
    ab_test_ = ab_test;
  } else {
    clear_has_ab_test();
    ab_test_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string url = 3;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconBatchRecord::url() const {
  return *url_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 network_error_code = 4;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_network_error_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_network_error_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_network_error_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_network_error_code() {
  network_error_code_ = 0;
  clear_has_network_error_code();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconBatchRecord::network_error_code() const {
  return network_error_code_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_network_error_code(::google::protobuf::int32 value) {
  set_has_network_error_code();
  network_error_code_ = value;
}

// optional int64 timestamp = 5;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 ClientBeaconBatch_ClientBeaconBatchRecord::timestamp() const {
  return timestamp_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.NetworkTimers network_timers = 6;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_network_timers() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_network_timers() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_network_timers() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_network_timers() {
  if (network_timers_ != NULL) network_timers_->::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers::Clear();
  clear_has_network_timers();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers& ClientBeaconBatch_ClientBeaconBatchRecord::network_timers() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return network_timers_ != NULL ? *network_timers_ : *default_instance().network_timers_;
#else
  return network_timers_ != NULL ? *network_timers_ : *default_instance_->network_timers_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* ClientBeaconBatch_ClientBeaconBatchRecord::mutable_network_timers() {
  set_has_network_timers();
  if (network_timers_ == NULL) network_timers_ = new ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers;
  return network_timers_;
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* ClientBeaconBatch_ClientBeaconBatchRecord::release_network_timers() {
  clear_has_network_timers();
  ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* temp = network_timers_;
  network_timers_ = NULL;
  return temp;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_allocated_network_timers(::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_NetworkTimers* network_timers) {
  delete network_timers_;
  network_timers_ = network_timers;
  if (network_timers) {
    set_has_network_timers();
  } else {
    clear_has_network_timers();
  }
}

// repeated .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord.TimerData custom_timers = 7;
inline int ClientBeaconBatch_ClientBeaconBatchRecord::custom_timers_size() const {
  return custom_timers_.size();
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_custom_timers() {
  custom_timers_.Clear();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData& ClientBeaconBatch_ClientBeaconBatchRecord::custom_timers(int index) const {
  return custom_timers_.Get(index);
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord::mutable_custom_timers(int index) {
  return custom_timers_.Mutable(index);
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData* ClientBeaconBatch_ClientBeaconBatchRecord::add_custom_timers() {
  return custom_timers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData >&
ClientBeaconBatch_ClientBeaconBatchRecord::custom_timers() const {
  return custom_timers_;
}
inline ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord_TimerData >*
ClientBeaconBatch_ClientBeaconBatchRecord::mutable_custom_timers() {
  return &custom_timers_;
}

// repeated int64 custom_metrics = 8;
inline int ClientBeaconBatch_ClientBeaconBatchRecord::custom_metrics_size() const {
  return custom_metrics_.size();
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_custom_metrics() {
  custom_metrics_.Clear();
}
inline ::google::protobuf::int64 ClientBeaconBatch_ClientBeaconBatchRecord::custom_metrics(int index) const {
  return custom_metrics_.Get(index);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_custom_metrics(int index, ::google::protobuf::int64 value) {
  custom_metrics_.Set(index, value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::add_custom_metrics(::google::protobuf::int64 value) {
  custom_metrics_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ClientBeaconBatch_ClientBeaconBatchRecord::custom_metrics() const {
  return custom_metrics_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ClientBeaconBatch_ClientBeaconBatchRecord::mutable_custom_metrics() {
  return &custom_metrics_;
}

// optional int32 beacon_total = 9;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_beacon_total() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_beacon_total() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_beacon_total() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_beacon_total() {
  beacon_total_ = 0;
  clear_has_beacon_total();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconBatchRecord::beacon_total() const {
  return beacon_total_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_beacon_total(::google::protobuf::int32 value) {
  set_has_beacon_total();
  beacon_total_ = value;
}

// optional int32 crashes_total = 10;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_crashes_total() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_crashes_total() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_crashes_total() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_crashes_total() {
  crashes_total_ = 0;
  clear_has_crashes_total();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconBatchRecord::crashes_total() const {
  return crashes_total_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_crashes_total(::google::protobuf::int32 value) {
  set_has_crashes_total();
  crashes_total_ = value;
}

// optional int32 installs_total = 11;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_installs_total() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_installs_total() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_installs_total() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_installs_total() {
  installs_total_ = 0;
  clear_has_installs_total();
}
inline ::google::protobuf::int32 ClientBeaconBatch_ClientBeaconBatchRecord::installs_total() const {
  return installs_total_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_installs_total(::google::protobuf::int32 value) {
  set_has_installs_total();
  installs_total_ = value;
}

// repeated string custom_dimensions = 12;
inline int ClientBeaconBatch_ClientBeaconBatchRecord::custom_dimensions_size() const {
  return custom_dimensions_.size();
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_custom_dimensions() {
  custom_dimensions_.Clear();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconBatchRecord::custom_dimensions(int index) const {
  return custom_dimensions_.Get(index);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::mutable_custom_dimensions(int index) {
  return custom_dimensions_.Mutable(index);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_custom_dimensions(int index, const ::std::string& value) {
  custom_dimensions_.Mutable(index)->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_custom_dimensions(int index, const char* value) {
  custom_dimensions_.Mutable(index)->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_custom_dimensions(int index, const char* value, size_t size) {
  custom_dimensions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::add_custom_dimensions() {
  return custom_dimensions_.Add();
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::add_custom_dimensions(const ::std::string& value) {
  custom_dimensions_.Add()->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::add_custom_dimensions(const char* value) {
  custom_dimensions_.Add()->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::add_custom_dimensions(const char* value, size_t size) {
  custom_dimensions_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClientBeaconBatch_ClientBeaconBatchRecord::custom_dimensions() const {
  return custom_dimensions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClientBeaconBatch_ClientBeaconBatchRecord::mutable_custom_dimensions() {
  return &custom_dimensions_;
}

// optional string beacon_type = 13;
inline bool ClientBeaconBatch_ClientBeaconBatchRecord::has_beacon_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_has_beacon_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_has_beacon_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::clear_beacon_type() {
  if (beacon_type_ != &::google::protobuf::internal::kEmptyString) {
    beacon_type_->clear();
  }
  clear_has_beacon_type();
}
inline const ::std::string& ClientBeaconBatch_ClientBeaconBatchRecord::beacon_type() const {
  return *beacon_type_;
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_beacon_type(const ::std::string& value) {
  set_has_beacon_type();
  if (beacon_type_ == &::google::protobuf::internal::kEmptyString) {
    beacon_type_ = new ::std::string;
  }
  beacon_type_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_beacon_type(const char* value) {
  set_has_beacon_type();
  if (beacon_type_ == &::google::protobuf::internal::kEmptyString) {
    beacon_type_ = new ::std::string;
  }
  beacon_type_->assign(value);
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_beacon_type(const char* value, size_t size) {
  set_has_beacon_type();
  if (beacon_type_ == &::google::protobuf::internal::kEmptyString) {
    beacon_type_ = new ::std::string;
  }
  beacon_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::mutable_beacon_type() {
  set_has_beacon_type();
  if (beacon_type_ == &::google::protobuf::internal::kEmptyString) {
    beacon_type_ = new ::std::string;
  }
  return beacon_type_;
}
inline ::std::string* ClientBeaconBatch_ClientBeaconBatchRecord::release_beacon_type() {
  clear_has_beacon_type();
  if (beacon_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = beacon_type_;
    beacon_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_ClientBeaconBatchRecord::set_allocated_beacon_type(::std::string* beacon_type) {
  if (beacon_type_ != &::google::protobuf::internal::kEmptyString) {
    delete beacon_type_;
  }
  if (beacon_type) {
    set_has_beacon_type();
    beacon_type_ = beacon_type;
  } else {
    clear_has_beacon_type();
    beacon_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientBeaconBatch_SessionInfo

// optional string id = 1;
inline bool ClientBeaconBatch_SessionInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch_SessionInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch_SessionInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch_SessionInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ClientBeaconBatch_SessionInfo::id() const {
  return *id_;
}
inline void ClientBeaconBatch_SessionInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ClientBeaconBatch_SessionInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ClientBeaconBatch_SessionInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch_SessionInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ClientBeaconBatch_SessionInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch_SessionInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 start_time = 2;
inline bool ClientBeaconBatch_SessionInfo::has_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch_SessionInfo::set_has_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch_SessionInfo::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch_SessionInfo::clear_start_time() {
  start_time_ = GOOGLE_LONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::int64 ClientBeaconBatch_SessionInfo::start_time() const {
  return start_time_;
}
inline void ClientBeaconBatch_SessionInfo::set_start_time(::google::protobuf::int64 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional int64 end_time = 3;
inline bool ClientBeaconBatch_SessionInfo::has_end_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientBeaconBatch_SessionInfo::set_has_end_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientBeaconBatch_SessionInfo::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientBeaconBatch_SessionInfo::clear_end_time() {
  end_time_ = GOOGLE_LONGLONG(0);
  clear_has_end_time();
}
inline ::google::protobuf::int64 ClientBeaconBatch_SessionInfo::end_time() const {
  return end_time_;
}
inline void ClientBeaconBatch_SessionInfo::set_end_time(::google::protobuf::int64 value) {
  set_has_end_time();
  end_time_ = value;
}

// optional int32 network_request_count_total = 4;
inline bool ClientBeaconBatch_SessionInfo::has_network_request_count_total() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientBeaconBatch_SessionInfo::set_has_network_request_count_total() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientBeaconBatch_SessionInfo::clear_has_network_request_count_total() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientBeaconBatch_SessionInfo::clear_network_request_count_total() {
  network_request_count_total_ = 0;
  clear_has_network_request_count_total();
}
inline ::google::protobuf::int32 ClientBeaconBatch_SessionInfo::network_request_count_total() const {
  return network_request_count_total_;
}
inline void ClientBeaconBatch_SessionInfo::set_network_request_count_total(::google::protobuf::int32 value) {
  set_has_network_request_count_total();
  network_request_count_total_ = value;
}

// optional int64 network_request_duration_total = 5;
inline bool ClientBeaconBatch_SessionInfo::has_network_request_duration_total() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientBeaconBatch_SessionInfo::set_has_network_request_duration_total() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientBeaconBatch_SessionInfo::clear_has_network_request_duration_total() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientBeaconBatch_SessionInfo::clear_network_request_duration_total() {
  network_request_duration_total_ = GOOGLE_LONGLONG(0);
  clear_has_network_request_duration_total();
}
inline ::google::protobuf::int64 ClientBeaconBatch_SessionInfo::network_request_duration_total() const {
  return network_request_duration_total_;
}
inline void ClientBeaconBatch_SessionInfo::set_network_request_duration_total(::google::protobuf::int64 value) {
  set_has_network_request_duration_total();
  network_request_duration_total_ = value;
}

// -------------------------------------------------------------------

// ClientBeaconBatch

// optional string boomerang_version = 1;
inline bool ClientBeaconBatch::has_boomerang_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientBeaconBatch::set_has_boomerang_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientBeaconBatch::clear_has_boomerang_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientBeaconBatch::clear_boomerang_version() {
  if (boomerang_version_ != &::google::protobuf::internal::kEmptyString) {
    boomerang_version_->clear();
  }
  clear_has_boomerang_version();
}
inline const ::std::string& ClientBeaconBatch::boomerang_version() const {
  return *boomerang_version_;
}
inline void ClientBeaconBatch::set_boomerang_version(const ::std::string& value) {
  set_has_boomerang_version();
  if (boomerang_version_ == &::google::protobuf::internal::kEmptyString) {
    boomerang_version_ = new ::std::string;
  }
  boomerang_version_->assign(value);
}
inline void ClientBeaconBatch::set_boomerang_version(const char* value) {
  set_has_boomerang_version();
  if (boomerang_version_ == &::google::protobuf::internal::kEmptyString) {
    boomerang_version_ = new ::std::string;
  }
  boomerang_version_->assign(value);
}
inline void ClientBeaconBatch::set_boomerang_version(const char* value, size_t size) {
  set_has_boomerang_version();
  if (boomerang_version_ == &::google::protobuf::internal::kEmptyString) {
    boomerang_version_ = new ::std::string;
  }
  boomerang_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_boomerang_version() {
  set_has_boomerang_version();
  if (boomerang_version_ == &::google::protobuf::internal::kEmptyString) {
    boomerang_version_ = new ::std::string;
  }
  return boomerang_version_;
}
inline ::std::string* ClientBeaconBatch::release_boomerang_version() {
  clear_has_boomerang_version();
  if (boomerang_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = boomerang_version_;
    boomerang_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_boomerang_version(::std::string* boomerang_version) {
  if (boomerang_version_ != &::google::protobuf::internal::kEmptyString) {
    delete boomerang_version_;
  }
  if (boomerang_version) {
    set_has_boomerang_version();
    boomerang_version_ = boomerang_version;
  } else {
    clear_has_boomerang_version();
    boomerang_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string domain = 2;
inline bool ClientBeaconBatch::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientBeaconBatch::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientBeaconBatch::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientBeaconBatch::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& ClientBeaconBatch::domain() const {
  return *domain_;
}
inline void ClientBeaconBatch::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void ClientBeaconBatch::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void ClientBeaconBatch::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* ClientBeaconBatch::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string api_key = 3;
inline bool ClientBeaconBatch::has_api_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientBeaconBatch::set_has_api_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientBeaconBatch::clear_has_api_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientBeaconBatch::clear_api_key() {
  if (api_key_ != &::google::protobuf::internal::kEmptyString) {
    api_key_->clear();
  }
  clear_has_api_key();
}
inline const ::std::string& ClientBeaconBatch::api_key() const {
  return *api_key_;
}
inline void ClientBeaconBatch::set_api_key(const ::std::string& value) {
  set_has_api_key();
  if (api_key_ == &::google::protobuf::internal::kEmptyString) {
    api_key_ = new ::std::string;
  }
  api_key_->assign(value);
}
inline void ClientBeaconBatch::set_api_key(const char* value) {
  set_has_api_key();
  if (api_key_ == &::google::protobuf::internal::kEmptyString) {
    api_key_ = new ::std::string;
  }
  api_key_->assign(value);
}
inline void ClientBeaconBatch::set_api_key(const char* value, size_t size) {
  set_has_api_key();
  if (api_key_ == &::google::protobuf::internal::kEmptyString) {
    api_key_ = new ::std::string;
  }
  api_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_api_key() {
  set_has_api_key();
  if (api_key_ == &::google::protobuf::internal::kEmptyString) {
    api_key_ = new ::std::string;
  }
  return api_key_;
}
inline ::std::string* ClientBeaconBatch::release_api_key() {
  clear_has_api_key();
  if (api_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = api_key_;
    api_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_api_key(::std::string* api_key) {
  if (api_key_ != &::google::protobuf::internal::kEmptyString) {
    delete api_key_;
  }
  if (api_key) {
    set_has_api_key();
    api_key_ = api_key;
  } else {
    clear_has_api_key();
    api_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device = 4;
inline bool ClientBeaconBatch::has_device() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientBeaconBatch::set_has_device() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientBeaconBatch::clear_has_device() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientBeaconBatch::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& ClientBeaconBatch::device() const {
  return *device_;
}
inline void ClientBeaconBatch::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void ClientBeaconBatch::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void ClientBeaconBatch::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* ClientBeaconBatch::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string manufacturer = 5;
inline bool ClientBeaconBatch::has_manufacturer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientBeaconBatch::set_has_manufacturer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientBeaconBatch::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientBeaconBatch::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& ClientBeaconBatch::manufacturer() const {
  return *manufacturer_;
}
inline void ClientBeaconBatch::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void ClientBeaconBatch::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void ClientBeaconBatch::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* ClientBeaconBatch::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (manufacturer) {
    set_has_manufacturer();
    manufacturer_ = manufacturer;
  } else {
    clear_has_manufacturer();
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 6;
inline bool ClientBeaconBatch::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientBeaconBatch::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientBeaconBatch::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientBeaconBatch::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ClientBeaconBatch::type() const {
  return *type_;
}
inline void ClientBeaconBatch::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ClientBeaconBatch::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ClientBeaconBatch::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* ClientBeaconBatch::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string os = 7;
inline bool ClientBeaconBatch::has_os() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientBeaconBatch::set_has_os() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientBeaconBatch::clear_has_os() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientBeaconBatch::clear_os() {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& ClientBeaconBatch::os() const {
  return *os_;
}
inline void ClientBeaconBatch::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void ClientBeaconBatch::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void ClientBeaconBatch::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  return os_;
}
inline ::std::string* ClientBeaconBatch::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string isp = 8;
inline bool ClientBeaconBatch::has_isp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientBeaconBatch::set_has_isp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientBeaconBatch::clear_has_isp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientBeaconBatch::clear_isp() {
  if (isp_ != &::google::protobuf::internal::kEmptyString) {
    isp_->clear();
  }
  clear_has_isp();
}
inline const ::std::string& ClientBeaconBatch::isp() const {
  return *isp_;
}
inline void ClientBeaconBatch::set_isp(const ::std::string& value) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(value);
}
inline void ClientBeaconBatch::set_isp(const char* value) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(value);
}
inline void ClientBeaconBatch::set_isp(const char* value, size_t size) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_isp() {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  return isp_;
}
inline ::std::string* ClientBeaconBatch::release_isp() {
  clear_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = isp_;
    isp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_isp(::std::string* isp) {
  if (isp_ != &::google::protobuf::internal::kEmptyString) {
    delete isp_;
  }
  if (isp) {
    set_has_isp();
    isp_ = isp;
  } else {
    clear_has_isp();
    isp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string connection_type = 9;
inline bool ClientBeaconBatch::has_connection_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientBeaconBatch::set_has_connection_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientBeaconBatch::clear_has_connection_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientBeaconBatch::clear_connection_type() {
  if (connection_type_ != &::google::protobuf::internal::kEmptyString) {
    connection_type_->clear();
  }
  clear_has_connection_type();
}
inline const ::std::string& ClientBeaconBatch::connection_type() const {
  return *connection_type_;
}
inline void ClientBeaconBatch::set_connection_type(const ::std::string& value) {
  set_has_connection_type();
  if (connection_type_ == &::google::protobuf::internal::kEmptyString) {
    connection_type_ = new ::std::string;
  }
  connection_type_->assign(value);
}
inline void ClientBeaconBatch::set_connection_type(const char* value) {
  set_has_connection_type();
  if (connection_type_ == &::google::protobuf::internal::kEmptyString) {
    connection_type_ = new ::std::string;
  }
  connection_type_->assign(value);
}
inline void ClientBeaconBatch::set_connection_type(const char* value, size_t size) {
  set_has_connection_type();
  if (connection_type_ == &::google::protobuf::internal::kEmptyString) {
    connection_type_ = new ::std::string;
  }
  connection_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_connection_type() {
  set_has_connection_type();
  if (connection_type_ == &::google::protobuf::internal::kEmptyString) {
    connection_type_ = new ::std::string;
  }
  return connection_type_;
}
inline ::std::string* ClientBeaconBatch::release_connection_type() {
  clear_has_connection_type();
  if (connection_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connection_type_;
    connection_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_connection_type(::std::string* connection_type) {
  if (connection_type_ != &::google::protobuf::internal::kEmptyString) {
    delete connection_type_;
  }
  if (connection_type) {
    set_has_connection_type();
    connection_type_ = connection_type;
  } else {
    clear_has_connection_type();
    connection_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string site_version = 10;
inline bool ClientBeaconBatch::has_site_version() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientBeaconBatch::set_has_site_version() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientBeaconBatch::clear_has_site_version() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientBeaconBatch::clear_site_version() {
  if (site_version_ != &::google::protobuf::internal::kEmptyString) {
    site_version_->clear();
  }
  clear_has_site_version();
}
inline const ::std::string& ClientBeaconBatch::site_version() const {
  return *site_version_;
}
inline void ClientBeaconBatch::set_site_version(const ::std::string& value) {
  set_has_site_version();
  if (site_version_ == &::google::protobuf::internal::kEmptyString) {
    site_version_ = new ::std::string;
  }
  site_version_->assign(value);
}
inline void ClientBeaconBatch::set_site_version(const char* value) {
  set_has_site_version();
  if (site_version_ == &::google::protobuf::internal::kEmptyString) {
    site_version_ = new ::std::string;
  }
  site_version_->assign(value);
}
inline void ClientBeaconBatch::set_site_version(const char* value, size_t size) {
  set_has_site_version();
  if (site_version_ == &::google::protobuf::internal::kEmptyString) {
    site_version_ = new ::std::string;
  }
  site_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientBeaconBatch::mutable_site_version() {
  set_has_site_version();
  if (site_version_ == &::google::protobuf::internal::kEmptyString) {
    site_version_ = new ::std::string;
  }
  return site_version_;
}
inline ::std::string* ClientBeaconBatch::release_site_version() {
  clear_has_site_version();
  if (site_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = site_version_;
    site_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientBeaconBatch::set_allocated_site_version(::std::string* site_version) {
  if (site_version_ != &::google::protobuf::internal::kEmptyString) {
    delete site_version_;
  }
  if (site_version) {
    set_has_site_version();
    site_version_ = site_version;
  } else {
    clear_has_site_version();
    site_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float latitude = 11;
inline bool ClientBeaconBatch::has_latitude() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientBeaconBatch::set_has_latitude() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientBeaconBatch::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientBeaconBatch::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float ClientBeaconBatch::latitude() const {
  return latitude_;
}
inline void ClientBeaconBatch::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
}

// optional float longitude = 12;
inline bool ClientBeaconBatch::has_longitude() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ClientBeaconBatch::set_has_longitude() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ClientBeaconBatch::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ClientBeaconBatch::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float ClientBeaconBatch::longitude() const {
  return longitude_;
}
inline void ClientBeaconBatch::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
}

// optional .client_beacon_batch.ClientBeaconBatch.SessionInfo session = 13;
inline bool ClientBeaconBatch::has_session() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ClientBeaconBatch::set_has_session() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ClientBeaconBatch::clear_has_session() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ClientBeaconBatch::clear_session() {
  if (session_ != NULL) session_->::client_beacon_batch::ClientBeaconBatch_SessionInfo::Clear();
  clear_has_session();
}
inline const ::client_beacon_batch::ClientBeaconBatch_SessionInfo& ClientBeaconBatch::session() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return session_ != NULL ? *session_ : *default_instance().session_;
#else
  return session_ != NULL ? *session_ : *default_instance_->session_;
#endif
}
inline ::client_beacon_batch::ClientBeaconBatch_SessionInfo* ClientBeaconBatch::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::client_beacon_batch::ClientBeaconBatch_SessionInfo;
  return session_;
}
inline ::client_beacon_batch::ClientBeaconBatch_SessionInfo* ClientBeaconBatch::release_session() {
  clear_has_session();
  ::client_beacon_batch::ClientBeaconBatch_SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}
inline void ClientBeaconBatch::set_allocated_session(::client_beacon_batch::ClientBeaconBatch_SessionInfo* session) {
  delete session_;
  session_ = session;
  if (session) {
    set_has_session();
  } else {
    clear_has_session();
  }
}

// repeated .client_beacon_batch.ClientBeaconBatch.ClientBeaconBatchRecord records = 14;
inline int ClientBeaconBatch::records_size() const {
  return records_.size();
}
inline void ClientBeaconBatch::clear_records() {
  records_.Clear();
}
inline const ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord& ClientBeaconBatch::records(int index) const {
  return records_.Get(index);
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord* ClientBeaconBatch::mutable_records(int index) {
  return records_.Mutable(index);
}
inline ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord* ClientBeaconBatch::add_records() {
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord >&
ClientBeaconBatch::records() const {
  return records_;
}
inline ::google::protobuf::RepeatedPtrField< ::client_beacon_batch::ClientBeaconBatch_ClientBeaconBatchRecord >*
ClientBeaconBatch::mutable_records() {
  return &records_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client_beacon_batch

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ClientBeaconBatch_2eproto__INCLUDED
